{"version":3,"file":"quiz-loader/index.js","mappings":"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","sources":["webpack://canvas-quiz-loader/./src/utils/data-utils.ts","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/display.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/monitor.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/getGlobalObject.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/byteUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/getZoneJsOriginalValue.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/timer.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/functionUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/serialisation/jsonStringify.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/objectUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/context/customerDataTracker.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/typeUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/mergeInto.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/serialisation/sanitize.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/observable.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/context/contextManager.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/trackingConsent.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/browser/addEventListener.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/context/storeContextManager.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/stackTrace/computeStackTrace.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/stackTrace/handlingStack.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/error/error.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/experimentalFeatures.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/configuration/intakeSites.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/timeUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/sendToExtension.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/numberUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/connectivity/connectivity.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/user/user.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/boot/displayAlreadyInitializedError.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/error/error.types.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/logger/isAuthorized.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/createErrorFieldFromRawError.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/logger.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/transport/eventBridge.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/urlPolyfill.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/browser/fetchObservable.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/stringUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/browserDetection.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/browser/cookie.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionStoreStrategy.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/polyfills.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/sessionConstants.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/sessionStateValidation.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/sessionState.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInCookie.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInLocalStorage.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/sessionStoreOperations.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/sessionStore.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/oldCookiesMigration.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/configuration/endpointBuilder.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/configuration/tags.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/configuration/transportConfiguration.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/configuration/configuration.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/configuration.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/boot/preStartLogs.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/boot/logsPublicApi.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/browser/pageExitObservable.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/valueHistory.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/logsSessionManager.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/contexts/rumInternalContext.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/assembly.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/console/consoleCollection.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/browser/xhrObservable.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/networkError/networkErrorCollection.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/lifeCycle.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/abstractLifeCycle.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/logger/loggerCollection.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/transport/batch.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/transport/httpRequest.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/transport/flushController.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/transport/startBatchWithReplica.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/tools/encoder.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/logsTelemetry.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/entries/main.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/contexts/commonContext.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/boot/startLogs.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/reportError.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/runtimeError/runtimeErrorCollection.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/report/reportCollection.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/transport/startLogsBridge.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/transport/startLogsBatch.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-logs/esm/domain/contexts/internalContext.js","webpack://canvas-quiz-loader/./node_modules/@datadog/browser-core/esm/boot/init.js","webpack://canvas-quiz-loader/./src/api-client/api-client.ts","webpack://canvas-quiz-loader/./src/config/config.ts","webpack://canvas-quiz-loader/./src/interfaces/message.interface.ts","webpack://canvas-quiz-loader/./src/logger/logger.ts","webpack://canvas-quiz-loader/./src/quiz-loader/submissions.ts","webpack://canvas-quiz-loader/./src/quiz-loader/types/question.ts","webpack://canvas-quiz-loader/./src/quiz-loader/question-types.ts","webpack://canvas-quiz-loader/./src/quiz-loader/display.ts","webpack://canvas-quiz-loader/./src/quiz-loader/helpers.ts","webpack://canvas-quiz-loader/./src/quiz-loader/quiz-loader.ts","webpack://canvas-quiz-loader/./src/quiz-loader/index.ts","webpack://canvas-quiz-loader/./src/quiz-loader/answers.ts"],"sourcesContent":["export function pickBy<T>(\r\n  obj: Record<string, T>, \r\n  predicate: (value: T, key: string) => boolean\r\n): Record<string, T> {\r\n  return Object.fromEntries(\r\n    Object.entries(obj).filter(([key, value]) => predicate(value as T, key))\r\n  );\r\n}\r\n\r\nexport function copyError<T extends object>(error: T): T {\r\n  if (!(error instanceof Error)) return error;\r\n\r\n  const clone: any = {}\r\n  Object.getOwnPropertyNames(error).forEach((key) => {\r\n      clone[key] = (error as any)[key];\r\n  });\r\n\r\n  return clone as T;\r\n}","/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\nexport const ConsoleApiName = {\n    log: 'log',\n    debug: 'debug',\n    info: 'info',\n    warn: 'warn',\n    error: 'error',\n};\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console;\nexport const originalConsoleMethods = {};\nObject.keys(ConsoleApiName).forEach((name) => {\n    originalConsoleMethods[name] = globalConsole[name];\n});\nconst PREFIX = 'Datadog Browser SDK:';\nexport const display = {\n    debug: originalConsoleMethods.debug.bind(globalConsole, PREFIX),\n    log: originalConsoleMethods.log.bind(globalConsole, PREFIX),\n    info: originalConsoleMethods.info.bind(globalConsole, PREFIX),\n    warn: originalConsoleMethods.warn.bind(globalConsole, PREFIX),\n    error: originalConsoleMethods.error.bind(globalConsole, PREFIX),\n};\nexport const DOCS_ORIGIN = 'https://docs.datadoghq.com';\nexport const DOCS_TROUBLESHOOTING = `${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting`;\nexport const MORE_DETAILS = 'More details:';\n//# sourceMappingURL=display.js.map","import { display } from './display';\nexport function catchUserErrors(fn, errorMsg) {\n    return (...args) => {\n        try {\n            return fn(...args);\n        }\n        catch (err) {\n            display.error(errorMsg, err);\n        }\n    };\n}\n//# sourceMappingURL=catchUserErrors.js.map","import { display } from './display';\nlet onMonitorErrorCollected;\nlet debugMode = false;\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected) {\n    onMonitorErrorCollected = newOnMonitorErrorCollected;\n}\nexport function setDebugMode(newDebugMode) {\n    debugMode = newDebugMode;\n}\nexport function resetMonitor() {\n    onMonitorErrorCollected = undefined;\n    debugMode = false;\n}\nexport function monitored(_, __, descriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n        const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod;\n        return decorated.apply(this, args);\n    };\n}\nexport function monitor(fn) {\n    return function () {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return callMonitored(fn, this, arguments);\n    }; // consider output type has input type\n}\nexport function callMonitored(fn, context, args) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return fn.apply(context, args);\n    }\n    catch (e) {\n        monitorError(e);\n    }\n}\nexport function monitorError(e) {\n    displayIfDebugEnabled(e);\n    if (onMonitorErrorCollected) {\n        try {\n            onMonitorErrorCollected(e);\n        }\n        catch (e) {\n            displayIfDebugEnabled(e);\n        }\n    }\n}\nexport function displayIfDebugEnabled(...args) {\n    if (debugMode) {\n        display.error('[MONITOR]', ...args);\n    }\n}\n//# sourceMappingURL=monitor.js.map","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\nexport function getGlobalObject() {\n    if (typeof globalThis === 'object') {\n        return globalThis;\n    }\n    Object.defineProperty(Object.prototype, '_dd_temp_', {\n        get() {\n            return this;\n        },\n        configurable: true,\n    });\n    // @ts-ignore _dd_temp is defined using defineProperty\n    let globalObject = _dd_temp_;\n    // @ts-ignore _dd_temp is defined using defineProperty\n    delete Object.prototype._dd_temp_;\n    if (typeof globalObject !== 'object') {\n        // on safari _dd_temp_ is available on window but not globally\n        // fallback on other browser globals check\n        if (typeof self === 'object') {\n            globalObject = self;\n        }\n        else if (typeof window === 'object') {\n            globalObject = window;\n        }\n        else {\n            globalObject = {};\n        }\n    }\n    return globalObject;\n}\n//# sourceMappingURL=getGlobalObject.js.map","export const ONE_KIBI_BYTE = 1024;\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE;\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/;\nexport function computeBytesCount(candidate) {\n    // Accurate bytes count computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n        return candidate.length;\n    }\n    if (window.TextEncoder !== undefined) {\n        return new TextEncoder().encode(candidate).length;\n    }\n    return new Blob([candidate]).size;\n}\nexport function concatBuffers(buffers) {\n    const length = buffers.reduce((total, buffer) => total + buffer.length, 0);\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const buffer of buffers) {\n        result.set(buffer, offset);\n        offset += buffer.length;\n    }\n    return result;\n}\n//# sourceMappingURL=byteUtils.js.map","import { getGlobalObject } from './getGlobalObject';\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue(target, name) {\n    const browserWindow = getGlobalObject();\n    let original;\n    if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n        original = target[browserWindow.Zone.__symbol__(name)];\n    }\n    if (!original) {\n        original = target[name];\n    }\n    return original;\n}\n//# sourceMappingURL=getZoneJsOriginalValue.js.map","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue';\nimport { monitor } from './monitor';\nimport { getGlobalObject } from './getGlobalObject';\nexport function setTimeout(callback, delay) {\n    return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay);\n}\nexport function clearTimeout(timeoutId) {\n    getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId);\n}\nexport function setInterval(callback, delay) {\n    return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay);\n}\nexport function clearInterval(timeoutId) {\n    getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId);\n}\n//# sourceMappingURL=timer.js.map","import { setTimeout, clearTimeout } from '../timer';\n// use lodash API\nexport function throttle(fn, wait, options) {\n    const needLeadingExecution = options && options.leading !== undefined ? options.leading : true;\n    const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true;\n    let inWaitPeriod = false;\n    let pendingExecutionWithParameters;\n    let pendingTimeoutId;\n    return {\n        throttled: (...parameters) => {\n            if (inWaitPeriod) {\n                pendingExecutionWithParameters = parameters;\n                return;\n            }\n            if (needLeadingExecution) {\n                fn(...parameters);\n            }\n            else {\n                pendingExecutionWithParameters = parameters;\n            }\n            inWaitPeriod = true;\n            pendingTimeoutId = setTimeout(() => {\n                if (needTrailingExecution && pendingExecutionWithParameters) {\n                    fn(...pendingExecutionWithParameters);\n                }\n                inWaitPeriod = false;\n                pendingExecutionWithParameters = undefined;\n            }, wait);\n        },\n        cancel: () => {\n            clearTimeout(pendingTimeoutId);\n            inWaitPeriod = false;\n            pendingExecutionWithParameters = undefined;\n        },\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() { }\n//# sourceMappingURL=functionUtils.js.map","import { noop } from '../utils/functionUtils';\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(value, replacer, space) {\n    if (typeof value !== 'object' || value === null) {\n        return JSON.stringify(value);\n    }\n    // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n    // subclasses.\n    const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n    const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n    const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value));\n    const restoreValueToJson = detachToJsonMethod(value);\n    try {\n        return JSON.stringify(value, replacer, space);\n    }\n    catch (_a) {\n        return '<error: unable to serialize object>';\n    }\n    finally {\n        restoreObjectPrototypeToJson();\n        restoreArrayPrototypeToJson();\n        restoreValuePrototypeToJson();\n        restoreValueToJson();\n    }\n}\nexport function detachToJsonMethod(value) {\n    const object = value;\n    const objectToJson = object.toJSON;\n    if (objectToJson) {\n        delete object.toJSON;\n        return () => {\n            object.toJSON = objectToJson;\n        };\n    }\n    return noop;\n}\n//# sourceMappingURL=jsonStringify.js.map","export function shallowClone(object) {\n    return { ...object };\n}\nexport function objectHasValue(object, value) {\n    return Object.keys(object).some((key) => object[key] === value);\n}\nexport function isEmptyObject(object) {\n    return Object.keys(object).length === 0;\n}\nexport function mapValues(object, fn) {\n    const newObject = {};\n    for (const key of Object.keys(object)) {\n        newObject[key] = fn(object[key]);\n    }\n    return newObject;\n}\n//# sourceMappingURL=objectUtils.js.map","import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../../tools/display';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE;\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport const CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE;\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200;\nexport function createCustomerDataTrackerManager(compressionStatus = 2 /* CustomerDataCompressionStatus.Disabled */) {\n    const customerDataTrackers = new Map();\n    let alreadyWarned = false;\n    function checkCustomerDataLimit(initialBytesCount = 0) {\n        if (alreadyWarned || compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n            return;\n        }\n        const bytesCountLimit = compressionStatus === 2 /* CustomerDataCompressionStatus.Disabled */\n            ? CUSTOMER_DATA_BYTES_LIMIT\n            : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT;\n        let bytesCount = initialBytesCount;\n        customerDataTrackers.forEach((tracker) => {\n            bytesCount += tracker.getBytesCount();\n        });\n        if (bytesCount > bytesCountLimit) {\n            displayCustomerDataLimitReachedWarning(bytesCountLimit);\n            alreadyWarned = true;\n        }\n    }\n    return {\n        /**\n         * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n         * bytes count will be counted independently from other detached trackers.\n         *\n         * This is particularly useful when we don't know when the tracker will be unused, so we don't\n         * leak memory (ex: when used in Logger instances).\n         */\n        createDetachedTracker: () => {\n            const tracker = createCustomerDataTracker(() => checkCustomerDataLimit(tracker.getBytesCount()));\n            return tracker;\n        },\n        /**\n         * Creates a tracker if it doesn't exist, and returns it.\n         */\n        getOrCreateTracker: (type) => {\n            if (!customerDataTrackers.has(type)) {\n                customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit));\n            }\n            return customerDataTrackers.get(type);\n        },\n        setCompressionStatus: (newCompressionStatus) => {\n            if (compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n                compressionStatus = newCompressionStatus;\n                checkCustomerDataLimit();\n            }\n        },\n        getCompressionStatus: () => compressionStatus,\n        stop: () => {\n            customerDataTrackers.forEach((tracker) => tracker.stop());\n            customerDataTrackers.clear();\n        },\n    };\n}\nexport function createCustomerDataTracker(checkCustomerDataLimit) {\n    let bytesCountCache = 0;\n    // Throttle the bytes computation to minimize the impact on performance.\n    // Especially useful if the user call context APIs synchronously multiple times in a row\n    const { throttled: computeBytesCountThrottled, cancel: cancelComputeBytesCount } = throttle((context) => {\n        bytesCountCache = computeBytesCount(jsonStringify(context));\n        checkCustomerDataLimit();\n    }, BYTES_COMPUTATION_THROTTLING_DELAY);\n    const resetBytesCount = () => {\n        cancelComputeBytesCount();\n        bytesCountCache = 0;\n    };\n    return {\n        updateCustomerData: (context) => {\n            if (isEmptyObject(context)) {\n                resetBytesCount();\n            }\n            else {\n                computeBytesCountThrottled(context);\n            }\n        },\n        resetCustomerData: resetBytesCount,\n        getBytesCount: () => bytesCountCache,\n        stop: () => {\n            cancelComputeBytesCount();\n        },\n    };\n}\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit) {\n    display.warn(`Customer data exceeds the recommended ${bytesCountLimit / ONE_KIBI_BYTE}KiB threshold. ${MORE_DETAILS} ${DOCS_TROUBLESHOOTING}/#customer-data-exceeds-the-recommended-threshold-warning`);\n}\n//# sourceMappingURL=customerDataTracker.js.map","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value) {\n    if (value === null) {\n        return 'null';\n    }\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n    return typeof value;\n}\n//# sourceMappingURL=typeUtils.js.map","import { getType } from './utils/typeUtils';\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto(destination, source, circularReferenceChecker = createCircularReferenceChecker()) {\n    // ignore the source if it is undefined\n    if (source === undefined) {\n        return destination;\n    }\n    if (typeof source !== 'object' || source === null) {\n        // primitive values - just return source\n        return source;\n    }\n    else if (source instanceof Date) {\n        return new Date(source.getTime());\n    }\n    else if (source instanceof RegExp) {\n        const flags = source.flags ||\n            // old browsers compatibility\n            [\n                source.global ? 'g' : '',\n                source.ignoreCase ? 'i' : '',\n                source.multiline ? 'm' : '',\n                source.sticky ? 'y' : '',\n                source.unicode ? 'u' : '',\n            ].join('');\n        return new RegExp(source.source, flags);\n    }\n    if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n        // remove circular references\n        return undefined;\n    }\n    else if (Array.isArray(source)) {\n        const merged = Array.isArray(destination) ? destination : [];\n        for (let i = 0; i < source.length; ++i) {\n            merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker);\n        }\n        return merged;\n    }\n    const merged = getType(destination) === 'object' ? destination : {};\n    for (const key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);\n        }\n    }\n    return merged;\n}\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone(value) {\n    return mergeInto(undefined, value);\n}\nexport function combine(...sources) {\n    let destination;\n    for (const source of sources) {\n        // Ignore any undefined or null sources.\n        if (source === undefined || source === null) {\n            continue;\n        }\n        destination = mergeInto(destination, source);\n    }\n    return destination;\n}\nfunction createCircularReferenceChecker() {\n    if (typeof WeakSet !== 'undefined') {\n        const set = new WeakSet();\n        return {\n            hasAlreadyBeenSeen(value) {\n                const has = set.has(value);\n                if (!has) {\n                    set.add(value);\n                }\n                return has;\n            },\n        };\n    }\n    const array = [];\n    return {\n        hasAlreadyBeenSeen(value) {\n            const has = array.indexOf(value) >= 0;\n            if (!has) {\n                array.push(value);\n            }\n            return has;\n        },\n    };\n}\n//# sourceMappingURL=mergeInto.js.map","import { display } from '../display';\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils';\nimport { detachToJsonMethod } from './jsonStringify';\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE;\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$';\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3;\nexport function sanitize(source, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n    // Unbind any toJSON function we may have on [] or {} prototypes\n    const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n    const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n    // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n    const containerQueue = [];\n    const visitedObjectsWithPath = new WeakMap();\n    const sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, undefined, containerQueue, visitedObjectsWithPath);\n    const serializedSanitizedData = JSON.stringify(sanitizedData);\n    let accumulatedCharacterCount = serializedSanitizedData ? serializedSanitizedData.length : 0;\n    if (accumulatedCharacterCount > maxCharacterCount) {\n        warnOverCharacterLimit(maxCharacterCount, 'discarded', source);\n        return undefined;\n    }\n    while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n        const containerToProcess = containerQueue.shift();\n        let separatorLength = 0; // 0 for the first element, 1 for subsequent elements\n        // Arrays and Objects have to be handled distinctly to ensure\n        // we do not pick up non-numerical properties from Arrays\n        if (Array.isArray(containerToProcess.source)) {\n            for (let key = 0; key < containerToProcess.source.length; key++) {\n                const targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n                if (targetData !== undefined) {\n                    accumulatedCharacterCount += JSON.stringify(targetData).length;\n                }\n                else {\n                    // When an element of an Array (targetData) is undefined, it is serialized as null:\n                    // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n                    accumulatedCharacterCount += 4;\n                }\n                accumulatedCharacterCount += separatorLength;\n                separatorLength = 1;\n                if (accumulatedCharacterCount > maxCharacterCount) {\n                    warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n                    break;\n                }\n                ;\n                containerToProcess.target[key] = targetData;\n            }\n        }\n        else {\n            for (const key in containerToProcess.source) {\n                if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n                    const targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n                    // When a property of an object has an undefined value, it will be dropped during serialization:\n                    // JSON.stringify({a:undefined}) => '{}'\n                    if (targetData !== undefined) {\n                        accumulatedCharacterCount +=\n                            JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;\n                        separatorLength = 1;\n                    }\n                    if (accumulatedCharacterCount > maxCharacterCount) {\n                        warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n                        break;\n                    }\n                    ;\n                    containerToProcess.target[key] = targetData;\n                }\n            }\n        }\n    }\n    // Rebind detached toJSON functions\n    restoreObjectPrototypeToJson();\n    restoreArrayPrototypeToJson();\n    return sanitizedData;\n}\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {\n    // Start by handling toJSON, as we want to sanitize its output\n    const sourceToSanitize = tryToApplyToJSON(source);\n    if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n        return sanitizePrimitivesAndFunctions(sourceToSanitize);\n    }\n    const sanitizedSource = sanitizeObjects(sourceToSanitize);\n    if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n        return sanitizedSource;\n    }\n    // Handle potential cyclic references\n    // We need to use source as sourceToSanitize could be a reference to a new object\n    // At this stage, we know the source is an object type\n    const sourceAsObject = source;\n    if (visitedObjectsWithPath.has(sourceAsObject)) {\n        return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)}]`;\n    }\n    // Add processed source to queue\n    const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath;\n    const target = Array.isArray(sourceToSanitize) ? [] : {};\n    visitedObjectsWithPath.set(sourceAsObject, currentPath);\n    queue.push({ source: sourceToSanitize, target, path: currentPath });\n    return target;\n}\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value) {\n    // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n    if (typeof value === 'bigint') {\n        return `[BigInt] ${value.toString()}`;\n    }\n    // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n    // so it won't prevent stringify from serializing later\n    if (typeof value === 'function') {\n        return `[Function] ${value.name || 'unknown'}`;\n    }\n    // JSON.stringify() does not serialize symbols.\n    if (typeof value === 'symbol') {\n        return `[Symbol] ${value.description || value.toString()}`;\n    }\n    return value;\n}\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n */\nfunction sanitizeObjects(value) {\n    try {\n        if (value instanceof Event) {\n            return sanitizeEvent(value);\n        }\n        if (value instanceof RegExp) {\n            return `[RegExp] ${value.toString()}`;\n        }\n        // Handle all remaining object types in a generic way\n        const result = Object.prototype.toString.call(value);\n        const match = result.match(/\\[object (.*)\\]/);\n        if (match && match[1]) {\n            return `[${match[1]}]`;\n        }\n    }\n    catch (_a) {\n        // If the previous serialization attempts failed, and we cannot convert using\n        // Object.prototype.toString, declare the value unserializable\n    }\n    return '[Unserializable]';\n}\nfunction sanitizeEvent(event) {\n    return {\n        type: event.type,\n        isTrusted: event.isTrusted,\n        currentTarget: event.currentTarget ? sanitizeObjects(event.currentTarget) : null,\n        target: event.target ? sanitizeObjects(event.target) : null,\n    };\n}\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value) {\n    const object = value;\n    if (object && typeof object.toJSON === 'function') {\n        try {\n            return object.toJSON();\n        }\n        catch (_a) {\n            // If toJSON fails, we continue by trying to serialize the value manually\n        }\n    }\n    return value;\n}\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount, changeType, source) {\n    display.warn(`The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`, source);\n}\n//# sourceMappingURL=sanitize.js.map","// eslint-disable-next-line no-restricted-syntax\nexport class Observable {\n    constructor(onFirstSubscribe) {\n        this.onFirstSubscribe = onFirstSubscribe;\n        this.observers = [];\n    }\n    subscribe(f) {\n        this.observers.push(f);\n        if (this.observers.length === 1 && this.onFirstSubscribe) {\n            this.onLastUnsubscribe = this.onFirstSubscribe(this) || undefined;\n        }\n        return {\n            unsubscribe: () => {\n                this.observers = this.observers.filter((other) => f !== other);\n                if (!this.observers.length && this.onLastUnsubscribe) {\n                    this.onLastUnsubscribe();\n                }\n            },\n        };\n    }\n    notify(data) {\n        this.observers.forEach((observer) => observer(data));\n    }\n}\nexport function mergeObservables(...observables) {\n    return new Observable((globalObservable) => {\n        const subscriptions = observables.map((observable) => observable.subscribe((data) => globalObservable.notify(data)));\n        return () => subscriptions.forEach((subscription) => subscription.unsubscribe());\n    });\n}\n//# sourceMappingURL=observable.js.map","import { deepClone } from '../../tools/mergeInto';\nimport { getType } from '../../tools/utils/typeUtils';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { Observable } from '../../tools/observable';\nexport function createContextManager(customerDataTracker) {\n    let context = {};\n    const changeObservable = new Observable();\n    const contextManager = {\n        getContext: () => deepClone(context),\n        setContext: (newContext) => {\n            if (getType(newContext) === 'object') {\n                context = sanitize(newContext);\n                customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            }\n            else {\n                contextManager.clearContext();\n            }\n            changeObservable.notify();\n        },\n        setContextProperty: (key, property) => {\n            context[key] = sanitize(property);\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            changeObservable.notify();\n        },\n        removeContextProperty: (key) => {\n            delete context[key];\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            changeObservable.notify();\n        },\n        clearContext: () => {\n            context = {};\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.resetCustomerData();\n            changeObservable.notify();\n        },\n        changeObservable,\n    };\n    return contextManager;\n}\n//# sourceMappingURL=contextManager.js.map","import { Observable } from '../tools/observable';\nexport const TrackingConsent = {\n    GRANTED: 'granted',\n    NOT_GRANTED: 'not-granted',\n};\nexport function createTrackingConsentState(currentConsent) {\n    const observable = new Observable();\n    return {\n        tryToInit(trackingConsent) {\n            if (!currentConsent) {\n                currentConsent = trackingConsent;\n            }\n        },\n        update(trackingConsent) {\n            currentConsent = trackingConsent;\n            observable.notify();\n        },\n        isGranted() {\n            return currentConsent === TrackingConsent.GRANTED;\n        },\n        observable,\n    };\n}\n//# sourceMappingURL=trackingConsent.js.map","import { monitor } from '../tools/monitor';\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue';\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener(configuration, eventTarget, eventName, listener, options) {\n    return addEventListeners(configuration, eventTarget, [eventName], listener, options);\n}\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners(configuration, eventTarget, eventNames, listener, { once, capture, passive } = {}) {\n    const listenerWithMonitor = monitor((event) => {\n        if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n            return;\n        }\n        if (once) {\n            stop();\n        }\n        listener(event);\n    });\n    const options = passive ? { capture, passive } : capture;\n    // Use the window.EventTarget.prototype when possible to avoid wrong overrides (e.g: https://github.com/salesforce/lwc/issues/1824)\n    const listenerTarget = window.EventTarget && eventTarget instanceof EventTarget ? window.EventTarget.prototype : eventTarget;\n    const add = getZoneJsOriginalValue(listenerTarget, 'addEventListener');\n    eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options));\n    function stop() {\n        const remove = getZoneJsOriginalValue(listenerTarget, 'removeEventListener');\n        eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options));\n    }\n    return {\n        stop,\n    };\n}\n//# sourceMappingURL=addEventListener.js.map","import { addEventListener } from '../../browser/addEventListener';\nimport { combine } from '../../tools/mergeInto';\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c';\nconst storageListeners = [];\nexport function storeContextManager(configuration, contextManager, productKey, customerDataType) {\n    const storageKey = buildStorageKey(productKey, customerDataType);\n    storageListeners.push(addEventListener(configuration, window, \"storage\" /* DOM_EVENT.STORAGE */, ({ key }) => {\n        if (storageKey === key) {\n            synchronizeWithStorage();\n        }\n    }));\n    contextManager.changeObservable.subscribe(dumpToStorage);\n    contextManager.setContext(combine(getFromStorage(), contextManager.getContext()));\n    function synchronizeWithStorage() {\n        contextManager.setContext(getFromStorage());\n    }\n    function dumpToStorage() {\n        localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()));\n    }\n    function getFromStorage() {\n        const rawContext = localStorage.getItem(storageKey);\n        return rawContext !== null ? JSON.parse(rawContext) : {};\n    }\n}\nexport function buildStorageKey(productKey, customerDataType) {\n    return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`;\n}\nexport function removeStorageListeners() {\n    storageListeners.map((listener) => listener.stop());\n}\n//# sourceMappingURL=storeContextManager.js.map","/**\n * Cross-browser stack trace computation.\n *\n * Reference implementation: https://github.com/csnover/TraceKit/blob/04530298073c3823de72deb0b97e7b38ca7bcb59/tracekit.js\n */\nconst UNKNOWN_FUNCTION = '?';\nexport function computeStackTrace(ex) {\n    const stack = [];\n    let stackProperty = tryToGetString(ex, 'stack');\n    const exString = String(ex);\n    if (stackProperty && stackProperty.startsWith(exString)) {\n        stackProperty = stackProperty.slice(exString.length);\n    }\n    if (stackProperty) {\n        stackProperty.split('\\n').forEach((line) => {\n            const stackFrame = parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line);\n            if (stackFrame) {\n                if (!stackFrame.func && stackFrame.line) {\n                    stackFrame.func = UNKNOWN_FUNCTION;\n                }\n                stack.push(stackFrame);\n            }\n        });\n    }\n    return {\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n        stack,\n    };\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|electron|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)';\nconst filePosition = '(?::(\\\\d+))';\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i');\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`);\nfunction parseChromeLine(line) {\n    const parts = CHROME_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    const isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n    const submatch = CHROME_EVAL_RE.exec(parts[2]);\n    if (isEval && submatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = submatch[1]; // url\n        parts[3] = submatch[2]; // line\n        parts[4] = submatch[3]; // column\n    }\n    return {\n        args: isNative ? [parts[2]] : [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[3] ? +parts[3] : undefined,\n        url: !isNative ? parts[2] : undefined,\n    };\n}\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i');\nfunction parseChromeAnonymousLine(line) {\n    const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    return {\n        args: [],\n        column: parts[3] ? +parts[3] : undefined,\n        func: UNKNOWN_FUNCTION,\n        line: parts[2] ? +parts[2] : undefined,\n        url: parts[1],\n    };\n}\nconst WINJS_LINE_RE = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseWinLine(line) {\n    const parts = WINJS_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    return {\n        args: [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: +parts[3],\n        url: parts[2],\n    };\n}\nconst GECKO_LINE_RE = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nfunction parseGeckoLine(line) {\n    const parts = GECKO_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    const submatch = GECKO_EVAL_RE.exec(parts[3]);\n    if (isEval && submatch) {\n        // throw out eval line/column and use top-most line number\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = undefined; // no column when eval\n    }\n    return {\n        args: parts[2] ? parts[2].split(',') : [],\n        column: parts[5] ? +parts[5] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[4] ? +parts[4] : undefined,\n        url: parts[3],\n    };\n}\nfunction tryToGetString(candidate, property) {\n    if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n        return undefined;\n    }\n    const value = candidate[property];\n    return typeof value === 'string' ? value : undefined;\n}\nexport function computeStackTraceFromOnErrorMessage(messageObj, url, line, column) {\n    const stack = [{ url, column, line }];\n    const { name, message } = tryToParseMessage(messageObj);\n    return {\n        name,\n        message,\n        stack,\n    };\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/;\nfunction tryToParseMessage(messageObj) {\n    let name;\n    let message;\n    if ({}.toString.call(messageObj) === '[object String]') {\n        ;\n        [, name, message] = ERROR_TYPES_RE.exec(messageObj);\n    }\n    return { name, message };\n}\n//# sourceMappingURL=computeStackTrace.js.map","import { callMonitored } from '../monitor';\nimport { computeStackTrace } from './computeStackTrace';\n/**\n * Creates a stacktrace without SDK internal frames.\n * Constraints:\n * - Has to be called at the utmost position of the call stack.\n * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack() {\n    /**\n     * Skip the two internal frames:\n     * - SDK API (console.error, ...)\n     * - this function\n     * in order to keep only the user calls\n     */\n    const internalFramesToSkip = 2;\n    const error = new Error();\n    let formattedStack;\n    callMonitored(() => {\n        const stackTrace = computeStackTrace(error);\n        stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);\n        formattedStack = toStackTraceString(stackTrace);\n    });\n    return formattedStack;\n}\nexport function toStackTraceString(stack) {\n    let result = formatErrorMessage(stack);\n    stack.stack.forEach((frame) => {\n        const func = frame.func === '?' ? '<anonymous>' : frame.func;\n        const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : '';\n        const line = frame.line ? `:${frame.line}` : '';\n        const column = frame.line && frame.column ? `:${frame.column}` : '';\n        result += `\\n  at ${func}${args} @ ${frame.url}${line}${column}`;\n    });\n    return result;\n}\nexport function formatErrorMessage(stack) {\n    return `${stack.name || 'Error'}: ${stack.message}`;\n}\n//# sourceMappingURL=handlingStack.js.map","import { sanitize } from '../../tools/serialisation/sanitize';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error';\nexport function computeRawError({ stackTrace, originalError, handlingStack, startClocks, nonErrorPrefix, source, handling, }) {\n    const isErrorInstance = isError(originalError);\n    const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError);\n    const stack = hasUsableStack(isErrorInstance, stackTrace)\n        ? toStackTraceString(stackTrace)\n        : NO_ERROR_STACK_PRESENT_MESSAGE;\n    const causes = isErrorInstance ? flattenErrorCauses(originalError, source) : undefined;\n    const type = stackTrace ? stackTrace.name : undefined;\n    const fingerprint = tryToGetFingerprint(originalError);\n    return {\n        startClocks,\n        source,\n        handling,\n        handlingStack,\n        originalError,\n        type,\n        message,\n        stack,\n        causes,\n        fingerprint,\n    };\n}\nfunction computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError) {\n    // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n    // TODO rework tracekit integration to avoid scattering error building logic\n    return (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.message) && (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name)\n        ? stackTrace.message\n        : !isErrorInstance\n            ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))}`\n            : 'Empty message';\n}\nfunction hasUsableStack(isErrorInstance, stackTrace) {\n    if (stackTrace === undefined) {\n        return false;\n    }\n    if (isErrorInstance) {\n        return true;\n    }\n    // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n    // TODO rework tracekit integration to avoid generating those unusable stack\n    return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined);\n}\nexport function tryToGetFingerprint(originalError) {\n    return isError(originalError) && 'dd_fingerprint' in originalError ? String(originalError.dd_fingerprint) : undefined;\n}\nexport function getFileFromStackTraceString(stack) {\n    var _a;\n    return (_a = /@ (.+)/.exec(stack)) === null || _a === void 0 ? void 0 : _a[1];\n}\nexport function isError(error) {\n    return error instanceof Error || Object.prototype.toString.call(error) === '[object Error]';\n}\nexport function flattenErrorCauses(error, parentSource) {\n    let currentError = error;\n    const causes = [];\n    while (isError(currentError === null || currentError === void 0 ? void 0 : currentError.cause) && causes.length < 10) {\n        const stackTrace = computeStackTrace(currentError.cause);\n        causes.push({\n            message: currentError.cause.message,\n            source: parentSource,\n            type: stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name,\n            stack: stackTrace && toStackTraceString(stackTrace),\n        });\n        currentError = currentError.cause;\n    }\n    return causes.length ? causes : undefined;\n}\n//# sourceMappingURL=error.js.map","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\nimport { objectHasValue } from './utils/objectUtils';\n// eslint-disable-next-line no-restricted-syntax\nexport var ExperimentalFeature;\n(function (ExperimentalFeature) {\n    ExperimentalFeature[\"WRITABLE_RESOURCE_GRAPHQL\"] = \"writable_resource_graphql\";\n    ExperimentalFeature[\"REMOTE_CONFIGURATION\"] = \"remote_configuration\";\n    ExperimentalFeature[\"ACTION_NAME_MASKING\"] = \"action_name_masking\";\n    ExperimentalFeature[\"CONSISTENT_TRACE_SAMPLING\"] = \"consistent_trace_sampling\";\n    ExperimentalFeature[\"DELAY_VIEWPORT_COLLECTION\"] = \"delay_viewport_collection\";\n})(ExperimentalFeature || (ExperimentalFeature = {}));\nconst enabledExperimentalFeatures = new Set();\nexport function initFeatureFlags(enableExperimentalFeatures) {\n    if (Array.isArray(enableExperimentalFeatures)) {\n        addExperimentalFeatures(enableExperimentalFeatures.filter((flag) => objectHasValue(ExperimentalFeature, flag)));\n    }\n}\nexport function addExperimentalFeatures(enabledFeatures) {\n    enabledFeatures.forEach((flag) => {\n        enabledExperimentalFeatures.add(flag);\n    });\n}\nexport function isExperimentalFeatureEnabled(featureName) {\n    return enabledExperimentalFeatures.has(featureName);\n}\nexport function resetExperimentalFeatures() {\n    enabledExperimentalFeatures.clear();\n}\nexport function getExperimentalFeatures() {\n    return enabledExperimentalFeatures;\n}\n//# sourceMappingURL=experimentalFeatures.js.map","export const INTAKE_SITE_STAGING = 'datad0g.com';\nexport const INTAKE_SITE_FED_STAGING = 'dd0g-gov.com';\nexport const INTAKE_SITE_US1 = 'datadoghq.com';\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu';\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com';\nexport const PCI_INTAKE_HOST_US1 = 'pci.browser-intake-datadoghq.com';\nexport const INTAKE_URL_PARAMETERS = ['ddsource', 'ddtags'];\n//# sourceMappingURL=intakeSites.js.map","import { isNumber, round } from './numberUtils';\nexport const ONE_SECOND = 1000;\nexport const ONE_MINUTE = 60 * ONE_SECOND;\nexport const ONE_HOUR = 60 * ONE_MINUTE;\nexport const ONE_DAY = 24 * ONE_HOUR;\nexport const ONE_YEAR = 365 * ONE_DAY;\nexport function relativeToClocks(relative) {\n    return { relative, timeStamp: getCorrectedTimeStamp(relative) };\n}\nexport function timeStampToClocks(timeStamp) {\n    return { relative: getRelativeTime(timeStamp), timeStamp };\n}\nfunction getCorrectedTimeStamp(relativeTime) {\n    const correctedOrigin = (dateNow() - performance.now());\n    // apply correction only for positive drift\n    if (correctedOrigin > getNavigationStart()) {\n        return Math.round(addDuration(correctedOrigin, relativeTime));\n    }\n    return getTimeStamp(relativeTime);\n}\nexport function currentDrift() {\n    return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now()));\n}\nexport function toServerDuration(duration) {\n    if (!isNumber(duration)) {\n        return duration;\n    }\n    return round(duration * 1e6, 0);\n}\nexport function dateNow() {\n    // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n    // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n    // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n    // case ourselves.\n    // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n    return new Date().getTime();\n}\nexport function timeStampNow() {\n    return dateNow();\n}\nexport function relativeNow() {\n    return performance.now();\n}\nexport function clocksNow() {\n    return { relative: relativeNow(), timeStamp: timeStampNow() };\n}\nexport function clocksOrigin() {\n    return { relative: 0, timeStamp: getNavigationStart() };\n}\nexport function elapsed(start, end) {\n    return (end - start);\n}\nexport function addDuration(a, b) {\n    return a + b;\n}\n// Get the time since the navigation was started.\nexport function getRelativeTime(timestamp) {\n    return (timestamp - getNavigationStart());\n}\nexport function getTimeStamp(relativeTime) {\n    return Math.round(addDuration(getNavigationStart(), relativeTime));\n}\nexport function looksLikeRelativeTime(time) {\n    return time < ONE_YEAR;\n}\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart;\n/**\n * Notes: this does not use `performance.timeOrigin` because:\n * - It doesn't seem to reflect the actual time on which the navigation has started: it may be much farther in the past,\n * at least in Firefox 71. (see: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926)\n * - It is not supported in Safari <15\n */\nfunction getNavigationStart() {\n    if (navigationStart === undefined) {\n        navigationStart = performance.timing.navigationStart;\n    }\n    return navigationStart;\n}\n//# sourceMappingURL=timeUtils.js.map","export function sendToExtension(type, payload) {\n    const callback = window.__ddBrowserSdkExtensionCallback;\n    if (callback) {\n        callback({ type, payload });\n    }\n}\n//# sourceMappingURL=sendToExtension.js.map","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold) {\n    return threshold !== 0 && Math.random() * 100 <= threshold;\n}\nexport function round(num, decimals) {\n    return +num.toFixed(decimals);\n}\nexport function isPercentage(value) {\n    return isNumber(value) && value >= 0 && value <= 100;\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\n//# sourceMappingURL=numberUtils.js.map","export function getConnectivity() {\n    var _a;\n    const navigator = window.navigator;\n    return {\n        status: navigator.onLine ? 'connected' : 'not_connected',\n        interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n        effective_type: (_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.effectiveType,\n    };\n}\n//# sourceMappingURL=connectivity.js.map","export function removeDuplicates(array) {\n    const set = new Set();\n    array.forEach((item) => set.add(item));\n    return Array.from(set);\n}\nexport function removeItem(array, item) {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrayUtils.js.map","import { removeItem } from './utils/arrayUtils';\nconst BUFFER_LIMIT = 500;\nexport function createBoundedBuffer() {\n    const buffer = [];\n    const add = (callback) => {\n        const length = buffer.push(callback);\n        if (length > BUFFER_LIMIT) {\n            buffer.splice(0, 1);\n        }\n    };\n    const remove = (callback) => {\n        removeItem(buffer, callback);\n    };\n    const drain = (arg) => {\n        buffer.forEach((callback) => callback(arg));\n        buffer.length = 0;\n    };\n    return {\n        add,\n        remove,\n        drain,\n    };\n}\n//# sourceMappingURL=boundedBuffer.js.map","export const TelemetryType = {\n    log: 'log',\n    configuration: 'configuration',\n    usage: 'usage',\n};\n//# sourceMappingURL=rawTelemetryEvent.types.js.map","import { ConsoleApiName } from '../../tools/display';\nimport { NO_ERROR_STACK_PRESENT_MESSAGE, isError } from '../error/error';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures';\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration';\nimport { Observable } from '../../tools/observable';\nimport { timeStampNow } from '../../tools/utils/timeUtils';\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor';\nimport { sendToExtension } from '../../tools/sendToExtension';\nimport { performDraw } from '../../tools/utils/numberUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { combine } from '../../tools/mergeInto';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { getConnectivity } from '../connectivity';\nimport { createBoundedBuffer } from '../../tools/boundedBuffer';\nimport { TelemetryType } from './rawTelemetryEvent.types';\nconst ALLOWED_FRAME_URLS = [\n    'https://www.datadoghq-browser-agent.com',\n    'https://www.datad0g-browser-agent.com',\n    'https://d3uc069fcn7uxw.cloudfront.net',\n    'https://d20xtzwzcl0ceb.cloudfront.net',\n    'http://localhost',\n    '<anonymous>',\n];\nconst TELEMETRY_EXCLUDED_SITES = [INTAKE_SITE_US1_FED];\n// eslint-disable-next-line local-rules/disallow-side-effects\nlet preStartTelemetryBuffer = createBoundedBuffer();\nlet onRawTelemetryEventCollected = (event) => {\n    preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event));\n};\nexport function startTelemetry(telemetryService, configuration) {\n    let contextProvider;\n    const observable = new Observable();\n    const alreadySentEvents = new Set();\n    const telemetryEnabled = !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && performDraw(configuration.telemetrySampleRate);\n    const telemetryEnabledPerType = {\n        [TelemetryType.log]: telemetryEnabled,\n        [TelemetryType.configuration]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n        [TelemetryType.usage]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n    };\n    const runtimeEnvInfo = getRuntimeEnvInfo();\n    onRawTelemetryEventCollected = (rawEvent) => {\n        const stringifiedEvent = jsonStringify(rawEvent);\n        if (telemetryEnabledPerType[rawEvent.type] &&\n            alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&\n            !alreadySentEvents.has(stringifiedEvent)) {\n            const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo);\n            observable.notify(event);\n            sendToExtension('telemetry', event);\n            alreadySentEvents.add(stringifiedEvent);\n        }\n    };\n    startMonitorErrorCollection(addTelemetryError);\n    function toTelemetryEvent(telemetryService, event, runtimeEnvInfo) {\n        return combine({\n            type: 'telemetry',\n            date: timeStampNow(),\n            service: telemetryService,\n            version: \"6.0.0\",\n            source: 'browser',\n            _dd: {\n                format_version: 2,\n            },\n            telemetry: combine(event, {\n                runtime_env: runtimeEnvInfo,\n                connectivity: getConnectivity(),\n                sdk_setup: \"npm\",\n            }),\n            experimental_features: Array.from(getExperimentalFeatures()),\n        }, contextProvider !== undefined ? contextProvider() : {});\n    }\n    return {\n        setContextProvider: (provider) => {\n            contextProvider = provider;\n        },\n        observable,\n        enabled: telemetryEnabled,\n    };\n}\nfunction getRuntimeEnvInfo() {\n    return {\n        is_local_file: window.location.protocol === 'file:',\n        is_worker: 'WorkerGlobalScope' in self,\n    };\n}\nexport function startFakeTelemetry() {\n    const events = [];\n    onRawTelemetryEventCollected = (event) => {\n        events.push(event);\n    };\n    return events;\n}\n// need to be called after telemetry context is provided and observers are registered\nexport function drainPreStartTelemetry() {\n    preStartTelemetryBuffer.drain();\n}\nexport function resetTelemetry() {\n    preStartTelemetryBuffer = createBoundedBuffer();\n    onRawTelemetryEventCollected = (event) => {\n        preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event));\n    };\n}\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration) {\n    return configuration.site === INTAKE_SITE_STAGING;\n}\nexport function addTelemetryDebug(message, context) {\n    displayIfDebugEnabled(ConsoleApiName.debug, message, context);\n    onRawTelemetryEventCollected({\n        type: TelemetryType.log,\n        message,\n        status: \"debug\" /* StatusType.debug */,\n        ...context,\n    });\n}\nexport function addTelemetryError(e, context) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.log,\n        status: \"error\" /* StatusType.error */,\n        ...formatError(e),\n        ...context,\n    });\n}\nexport function addTelemetryConfiguration(configuration) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.configuration,\n        configuration,\n    });\n}\nexport function addTelemetryUsage(usage) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.usage,\n        usage,\n    });\n}\nexport function formatError(e) {\n    if (isError(e)) {\n        const stackTrace = computeStackTrace(e);\n        return {\n            error: {\n                kind: stackTrace.name,\n                stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n            },\n            message: stackTrace.message,\n        };\n    }\n    return {\n        error: {\n            stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n        },\n        message: `${\"Uncaught\" /* NonErrorPrefix.UNCAUGHT */} ${jsonStringify(e)}`,\n    };\n}\nexport function scrubCustomerFrames(stackTrace) {\n    stackTrace.stack = stackTrace.stack.filter((frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url.startsWith(allowedFrameUrl)));\n    return stackTrace;\n}\n//# sourceMappingURL=telemetry.js.map","import { display } from '../../tools/display';\nimport { getType } from '../../tools/utils/typeUtils';\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser) {\n    // We shallow clone only to prevent mutation of user data.\n    const user = { ...newUser };\n    const keys = ['id', 'name', 'email'];\n    keys.forEach((key) => {\n        if (key in user) {\n            /* eslint-disable @typescript-eslint/no-base-to-string */\n            user[key] = String(user[key]);\n        }\n    });\n    return user;\n}\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser) {\n    const isValid = getType(newUser) === 'object';\n    if (!isValid) {\n        display.error('Unsupported user:', newUser);\n    }\n    return isValid;\n}\nexport function generateAnonymousId() {\n    return Math.floor(Math.random() * Math.pow(36, 10))\n        .toString(36)\n        .padStart(10, '0');\n}\n//# sourceMappingURL=user.js.map","import { display } from '../tools/display';\nexport function displayAlreadyInitializedError(sdkName, initConfiguration) {\n    if (!initConfiguration.silentMultipleInit) {\n        display.error(`${sdkName} is already initialized.`);\n    }\n}\n//# sourceMappingURL=displayAlreadyInitializedError.js.map","export const ErrorSource = {\n    AGENT: 'agent',\n    CONSOLE: 'console',\n    CUSTOM: 'custom',\n    LOGGER: 'logger',\n    NETWORK: 'network',\n    SOURCE: 'source',\n    REPORT: 'report',\n};\n//# sourceMappingURL=error.types.js.map","export function isAuthorized(status, handlerType, logger) {\n    const loggerHandler = logger.getHandler();\n    const sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [loggerHandler];\n    return STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && sanitizedHandlerType.includes(handlerType);\n}\nexport const StatusType = {\n    ok: 'ok',\n    debug: 'debug',\n    info: 'info',\n    notice: 'notice',\n    warn: 'warn',\n    error: 'error',\n    critical: 'critical',\n    alert: 'alert',\n    emerg: 'emerg',\n};\nexport const STATUS_PRIORITIES = {\n    [StatusType.ok]: 0,\n    [StatusType.debug]: 1,\n    [StatusType.info]: 2,\n    [StatusType.notice]: 4,\n    [StatusType.warn]: 5,\n    [StatusType.error]: 6,\n    [StatusType.critical]: 7,\n    [StatusType.alert]: 8,\n    [StatusType.emerg]: 9,\n};\n//# sourceMappingURL=isAuthorized.js.map","export function createErrorFieldFromRawError(rawError, { \n/**\n * Set this to `true` to include the error message in the error field. In most cases, the error\n * message is already included in the log message, so we don't need to include it again.\n */\nincludeMessage = false, } = {}) {\n    return {\n        stack: rawError.stack,\n        kind: rawError.type,\n        message: includeMessage ? rawError.message : undefined,\n        causes: rawError.causes,\n        fingerprint: rawError.fingerprint,\n        handling: rawError.handling,\n    };\n}\n//# sourceMappingURL=createErrorFieldFromRawError.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { clocksNow, computeRawError, computeStackTrace, combine, createContextManager, ErrorSource, monitored, sanitize, createHandlingStack, isError, } from '@datadog/browser-core';\nimport { isAuthorized, StatusType } from './logger/isAuthorized';\nimport { createErrorFieldFromRawError } from './createErrorFieldFromRawError';\nexport const HandlerType = {\n    console: 'console',\n    http: 'http',\n    silent: 'silent',\n};\nexport const STATUSES = Object.keys(StatusType);\n// note: it is safe to merge declarations as long as the methods are actually defined on the prototype\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging, no-restricted-syntax\nexport class Logger {\n    constructor(handleLogStrategy, customerDataTracker, name, handlerType = HandlerType.http, level = StatusType.debug, loggerContext = {}) {\n        this.handleLogStrategy = handleLogStrategy;\n        this.handlerType = handlerType;\n        this.level = level;\n        this.contextManager = createContextManager(customerDataTracker);\n        this.contextManager.setContext(loggerContext);\n        if (name) {\n            this.contextManager.setContextProperty('logger', { name });\n        }\n    }\n    logImplementation(message, messageContext, status = StatusType.info, error, handlingStack) {\n        const sanitizedMessageContext = sanitize(messageContext);\n        let context;\n        if (error !== undefined && error !== null) {\n            const rawError = computeRawError({\n                stackTrace: isError(error) ? computeStackTrace(error) : undefined,\n                originalError: error,\n                nonErrorPrefix: \"Provided\" /* NonErrorPrefix.PROVIDED */,\n                source: ErrorSource.LOGGER,\n                handling: \"handled\" /* ErrorHandling.HANDLED */,\n                startClocks: clocksNow(),\n            });\n            context = combine({\n                error: createErrorFieldFromRawError(rawError, { includeMessage: true }),\n            }, sanitizedMessageContext);\n        }\n        else {\n            context = sanitizedMessageContext;\n        }\n        this.handleLogStrategy({\n            message: sanitize(message),\n            context,\n            status,\n        }, this, handlingStack);\n    }\n    log(message, messageContext, status = StatusType.info, error) {\n        let handlingStack;\n        if (isAuthorized(status, HandlerType.http, this)) {\n            handlingStack = createHandlingStack();\n        }\n        this.logImplementation(message, messageContext, status, error, handlingStack);\n    }\n    setContext(context) {\n        this.contextManager.setContext(context);\n    }\n    getContext() {\n        return this.contextManager.getContext();\n    }\n    setContextProperty(key, value) {\n        this.contextManager.setContextProperty(key, value);\n    }\n    removeContextProperty(key) {\n        this.contextManager.removeContextProperty(key);\n    }\n    clearContext() {\n        this.contextManager.clearContext();\n    }\n    setHandler(handler) {\n        this.handlerType = handler;\n    }\n    getHandler() {\n        return this.handlerType;\n    }\n    setLevel(level) {\n        this.level = level;\n    }\n    getLevel() {\n        return this.level;\n    }\n}\n__decorate([\n    monitored\n], Logger.prototype, \"logImplementation\", null);\n/* eslint-disable local-rules/disallow-side-effects */\nLogger.prototype.ok = createLoggerMethod(StatusType.ok);\nLogger.prototype.debug = createLoggerMethod(StatusType.debug);\nLogger.prototype.info = createLoggerMethod(StatusType.info);\nLogger.prototype.notice = createLoggerMethod(StatusType.notice);\nLogger.prototype.warn = createLoggerMethod(StatusType.warn);\nLogger.prototype.error = createLoggerMethod(StatusType.error);\nLogger.prototype.critical = createLoggerMethod(StatusType.critical);\nLogger.prototype.alert = createLoggerMethod(StatusType.alert);\nLogger.prototype.emerg = createLoggerMethod(StatusType.emerg);\nfunction createLoggerMethod(status) {\n    return function (message, messageContext, error) {\n        let handlingStack;\n        if (isAuthorized(status, HandlerType.http, this)) {\n            handlingStack = createHandlingStack();\n        }\n        this.logImplementation(message, messageContext, status, error, handlingStack);\n    };\n}\n//# sourceMappingURL=logger.js.map","import { getGlobalObject } from '../tools/getGlobalObject';\nexport function getEventBridge() {\n    const eventBridgeGlobal = getEventBridgeGlobal();\n    if (!eventBridgeGlobal) {\n        return;\n    }\n    return {\n        getCapabilities() {\n            var _a;\n            return JSON.parse(((_a = eventBridgeGlobal.getCapabilities) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal)) || '[]');\n        },\n        getPrivacyLevel() {\n            var _a;\n            return (_a = eventBridgeGlobal.getPrivacyLevel) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal);\n        },\n        getAllowedWebViewHosts() {\n            return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());\n        },\n        send(eventType, event, viewId) {\n            const view = viewId ? { id: viewId } : undefined;\n            eventBridgeGlobal.send(JSON.stringify({ eventType, event, view }));\n        },\n    };\n}\nexport function bridgeSupports(capability) {\n    const bridge = getEventBridge();\n    return !!bridge && bridge.getCapabilities().includes(capability);\n}\nexport function canUseEventBridge(currentHost) {\n    var _a;\n    if (currentHost === void 0) { currentHost = (_a = getGlobalObject().location) === null || _a === void 0 ? void 0 : _a.hostname; }\n    const bridge = getEventBridge();\n    return (!!bridge &&\n        bridge\n            .getAllowedWebViewHosts()\n            .some((allowedHost) => currentHost === allowedHost || currentHost.endsWith(`.${allowedHost}`)));\n}\nfunction getEventBridgeGlobal() {\n    return getGlobalObject().DatadogEventBridge;\n}\n//# sourceMappingURL=eventBridge.js.map","import { setTimeout } from './timer';\nimport { callMonitored } from './monitor';\nimport { noop } from './utils/functionUtils';\nimport { createHandlingStack } from './stackTrace/handlingStack';\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod(targetPrototype, method, onPreCall, { computeHandlingStack } = {}) {\n    let original = targetPrototype[method];\n    if (typeof original !== 'function') {\n        if (method in targetPrototype && method.startsWith('on')) {\n            original = noop;\n        }\n        else {\n            return { stop: noop };\n        }\n    }\n    let stopped = false;\n    const instrumentation = function () {\n        if (stopped) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n            return original.apply(this, arguments);\n        }\n        const parameters = Array.from(arguments);\n        let postCallCallback;\n        callMonitored(onPreCall, null, [\n            {\n                target: this,\n                parameters,\n                onPostCall: (callback) => {\n                    postCallCallback = callback;\n                },\n                handlingStack: computeHandlingStack ? createHandlingStack() : undefined,\n            },\n        ]);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const result = original.apply(this, parameters);\n        if (postCallCallback) {\n            callMonitored(postCallCallback, null, [result]);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result;\n    };\n    targetPrototype[method] = instrumentation;\n    return {\n        stop: () => {\n            stopped = true;\n            // If the instrumentation has been removed by a third party, keep the last one\n            if (targetPrototype[method] === instrumentation) {\n                targetPrototype[method] = original;\n            }\n        },\n    };\n}\nexport function instrumentSetter(targetPrototype, property, after) {\n    const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property);\n    if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n        return { stop: noop };\n    }\n    const stoppedInstrumentation = noop;\n    let instrumentation = (target, value) => {\n        // put hooked setter into event loop to avoid of set latency\n        setTimeout(() => {\n            if (instrumentation !== stoppedInstrumentation) {\n                after(target, value);\n            }\n        }, 0);\n    };\n    const instrumentationWrapper = function (value) {\n        originalDescriptor.set.call(this, value);\n        instrumentation(this, value);\n    };\n    Object.defineProperty(targetPrototype, property, {\n        set: instrumentationWrapper,\n    });\n    return {\n        stop: () => {\n            var _a;\n            if (((_a = Object.getOwnPropertyDescriptor(targetPrototype, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {\n                Object.defineProperty(targetPrototype, property, originalDescriptor);\n            }\n            instrumentation = stoppedInstrumentation;\n        },\n    };\n}\n//# sourceMappingURL=instrumentMethod.js.map","import { jsonStringify } from '../serialisation/jsonStringify';\nexport function normalizeUrl(url) {\n    return buildUrl(url, location.href).href;\n}\nexport function isValidUrl(url) {\n    try {\n        return !!buildUrl(url);\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function getPathName(url) {\n    const pathname = buildUrl(url).pathname;\n    return pathname[0] === '/' ? pathname : `/${pathname}`;\n}\nexport function buildUrl(url, base) {\n    const supportedURL = getSupportedUrl();\n    if (supportedURL) {\n        try {\n            return base !== undefined ? new supportedURL(url, base) : new supportedURL(url);\n        }\n        catch (error) {\n            throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })}`);\n        }\n    }\n    if (base === undefined && !/:/.test(url)) {\n        throw new Error(`Invalid URL: '${url}'`);\n    }\n    let doc = document;\n    const anchorElement = doc.createElement('a');\n    if (base !== undefined) {\n        doc = document.implementation.createHTMLDocument('');\n        const baseElement = doc.createElement('base');\n        baseElement.href = base;\n        doc.head.appendChild(baseElement);\n        doc.body.appendChild(anchorElement);\n    }\n    anchorElement.href = url;\n    return anchorElement;\n}\nconst originalURL = URL;\nlet isURLSupported;\nfunction getSupportedUrl() {\n    if (isURLSupported === undefined) {\n        try {\n            const url = new originalURL('http://test/path');\n            isURLSupported = url.href === 'http://test/path';\n        }\n        catch (_a) {\n            isURLSupported = false;\n        }\n    }\n    return isURLSupported ? originalURL : undefined;\n}\n//# sourceMappingURL=urlPolyfill.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { monitor } from '../tools/monitor';\nimport { Observable } from '../tools/observable';\nimport { clocksNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nlet fetchObservable;\nexport function initFetchObservable() {\n    if (!fetchObservable) {\n        fetchObservable = createFetchObservable();\n    }\n    return fetchObservable;\n}\nexport function resetFetchObservable() {\n    fetchObservable = undefined;\n}\nfunction createFetchObservable() {\n    return new Observable((observable) => {\n        if (!window.fetch) {\n            return;\n        }\n        const { stop } = instrumentMethod(window, 'fetch', (call) => beforeSend(call, observable), {\n            computeHandlingStack: true,\n        });\n        return stop;\n    });\n}\nfunction beforeSend({ parameters, onPostCall, handlingStack }, observable) {\n    const [input, init] = parameters;\n    let methodFromParams = init && init.method;\n    if (methodFromParams === undefined && input instanceof Request) {\n        methodFromParams = input.method;\n    }\n    const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET';\n    const url = input instanceof Request ? input.url : normalizeUrl(String(input));\n    const startClocks = clocksNow();\n    const context = {\n        state: 'start',\n        init,\n        input,\n        method,\n        startClocks,\n        url,\n        handlingStack,\n    };\n    observable.notify(context);\n    // Those properties can be changed by observable subscribers\n    parameters[0] = context.input;\n    parameters[1] = context.init;\n    onPostCall((responsePromise) => afterSend(observable, responsePromise, context));\n}\nfunction afterSend(observable, responsePromise, startContext) {\n    const context = startContext;\n    function reportFetch(partialContext) {\n        context.state = 'resolve';\n        Object.assign(context, partialContext);\n        observable.notify(context);\n    }\n    responsePromise.then(monitor((response) => {\n        reportFetch({\n            response,\n            responseType: response.type,\n            status: response.status,\n            isAborted: false,\n        });\n    }), monitor((error) => {\n        var _a, _b;\n        reportFetch({\n            status: 0,\n            isAborted: ((_b = (_a = context.init) === null || _a === void 0 ? void 0 : _a.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (error instanceof DOMException && error.code === DOMException.ABORT_ERR),\n            error,\n        });\n    }));\n}\n//# sourceMappingURL=fetchObservable.js.map","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder) {\n    return placeholder\n        ? // eslint-disable-next-line  no-bitwise\n            (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n        : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID);\n}\nconst COMMA_SEPARATED_KEY_VALUE = /([\\w-]+)\\s*=\\s*([^;]+)/g;\nexport function findCommaSeparatedValue(rawString, name) {\n    COMMA_SEPARATED_KEY_VALUE.lastIndex = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString);\n        if (match) {\n            if (match[1] === name) {\n                return match[2];\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nexport function findCommaSeparatedValues(rawString) {\n    const result = new Map();\n    COMMA_SEPARATED_KEY_VALUE.lastIndex = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString);\n        if (match) {\n            result.set(match[1], match[2]);\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\nexport function safeTruncate(candidate, length, suffix = '') {\n    const lastChar = candidate.charCodeAt(length - 1);\n    const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff;\n    const correctedLength = isLastCharSurrogatePair ? length + 1 : length;\n    if (candidate.length <= correctedLength) {\n        return candidate;\n    }\n    return `${candidate.slice(0, correctedLength)}${suffix}`;\n}\n//# sourceMappingURL=stringUtils.js.map","export function isChromium() {\n    return detectBrowserCached() === 0 /* Browser.CHROMIUM */;\n}\nexport function isSafari() {\n    return detectBrowserCached() === 1 /* Browser.SAFARI */;\n}\nlet browserCache;\nfunction detectBrowserCached() {\n    return browserCache !== null && browserCache !== void 0 ? browserCache : (browserCache = detectBrowser());\n}\n// Exported only for tests\nexport function detectBrowser(browserWindow = window) {\n    var _a;\n    const userAgent = browserWindow.navigator.userAgent;\n    if (browserWindow.chrome || /HeadlessChrome/.test(userAgent)) {\n        return 0 /* Browser.CHROMIUM */;\n    }\n    if (\n    // navigator.vendor is deprecated, but it is the most resilient way we found to detect\n    // \"Apple maintained browsers\" (AKA Safari). If one day it gets removed, we still have the\n    // useragent test as a semi-working fallback.\n    ((_a = browserWindow.navigator.vendor) === null || _a === void 0 ? void 0 : _a.indexOf('Apple')) === 0 ||\n        (/safari/i.test(userAgent) && !/chrome|android/i.test(userAgent))) {\n        return 1 /* Browser.SAFARI */;\n    }\n    return 2 /* Browser.OTHER */;\n}\n//# sourceMappingURL=browserDetection.js.map","import { display } from '../tools/display';\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { findCommaSeparatedValue, findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils';\nexport function setCookie(name, value, expireDelay = 0, options) {\n    const date = new Date();\n    date.setTime(date.getTime() + expireDelay);\n    const expires = `expires=${date.toUTCString()}`;\n    const sameSite = options && options.crossSite ? 'none' : 'strict';\n    const domain = options && options.domain ? `;domain=${options.domain}` : '';\n    const secure = options && options.secure ? ';secure' : '';\n    const partitioned = options && options.partitioned ? ';partitioned' : '';\n    document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}${partitioned}`;\n}\nexport function getCookie(name) {\n    return findCommaSeparatedValue(document.cookie, name);\n}\nlet initCookieParsed;\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name) {\n    if (!initCookieParsed) {\n        initCookieParsed = findCommaSeparatedValues(document.cookie);\n    }\n    return initCookieParsed.get(name);\n}\nexport function resetInitCookies() {\n    initCookieParsed = undefined;\n}\nexport function deleteCookie(name, options) {\n    setCookie(name, '', 0, options);\n}\nexport function areCookiesAuthorized(options) {\n    if (document.cookie === undefined || document.cookie === null) {\n        return false;\n    }\n    try {\n        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n        // the test cookie lifetime\n        const testCookieName = `dd_cookie_test_${generateUUID()}`;\n        const testCookieValue = 'test';\n        setCookie(testCookieName, testCookieValue, ONE_MINUTE, options);\n        const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;\n        deleteCookie(testCookieName, options);\n        return isCookieCorrectlySet;\n    }\n    catch (error) {\n        display.error(error);\n        return false;\n    }\n}\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache;\nexport function getCurrentSite() {\n    if (getCurrentSiteCache === undefined) {\n        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n        // the test cookie lifetime\n        const testCookieName = `dd_site_test_${generateUUID()}`;\n        const testCookieValue = 'test';\n        const domainLevels = window.location.hostname.split('.');\n        let candidateDomain = domainLevels.pop();\n        while (domainLevels.length && !getCookie(testCookieName)) {\n            candidateDomain = `${domainLevels.pop()}.${candidateDomain}`;\n            setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain });\n        }\n        deleteCookie(testCookieName, { domain: candidateDomain });\n        getCurrentSiteCache = candidateDomain;\n    }\n    return getCurrentSiteCache;\n}\n//# sourceMappingURL=cookie.js.map","export const SESSION_STORE_KEY = '_dd_s';\n//# sourceMappingURL=sessionStoreStrategy.js.map","export function findLast(array, predicate) {\n    for (let i = array.length - 1; i >= 0; i -= 1) {\n        const item = array[i];\n        if (predicate(item, i, array)) {\n            return item;\n        }\n    }\n    return undefined;\n}\n// Keep the following wrapper functions as it can be mangled and will result in smaller bundle size that using\n// the native Object.values and Object.entries directly\nexport function objectValues(object) {\n    return Object.values(object);\n}\nexport function objectEntries(object) {\n    return Object.entries(object);\n}\n//# sourceMappingURL=polyfills.js.map","import { ONE_HOUR, ONE_MINUTE, ONE_YEAR } from '../../tools/utils/timeUtils';\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR;\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE;\nexport const SESSION_COOKIE_EXPIRATION_DELAY = ONE_YEAR;\nexport const SessionPersistence = {\n    COOKIE: 'cookie',\n    LOCAL_STORAGE: 'local-storage',\n};\n//# sourceMappingURL=sessionConstants.js.map","export const SESSION_ENTRY_REGEXP = /^([a-zA-Z]+)=([a-z0-9-]+)$/;\nexport const SESSION_ENTRY_SEPARATOR = '&';\nexport function isValidSessionString(sessionString) {\n    return (!!sessionString &&\n        (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString)));\n}\n//# sourceMappingURL=sessionStateValidation.js.map","import { isEmptyObject } from '../../tools/utils/objectUtils';\nimport { objectEntries } from '../../tools/utils/polyfills';\nimport { dateNow } from '../../tools/utils/timeUtils';\nimport { generateAnonymousId } from '../user';\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { isValidSessionString, SESSION_ENTRY_REGEXP, SESSION_ENTRY_SEPARATOR } from './sessionStateValidation';\nexport const EXPIRED = '1';\nexport function getExpiredSessionState(previousSessionState, configuration) {\n    const expiredSessionState = {\n        isExpired: EXPIRED,\n    };\n    if (configuration.trackAnonymousUser) {\n        if (previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId) {\n            expiredSessionState.anonymousId = previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId;\n        }\n        else {\n            expiredSessionState.anonymousId = generateAnonymousId();\n        }\n    }\n    return expiredSessionState;\n}\nexport function isSessionInNotStartedState(session) {\n    return isEmptyObject(session);\n}\nexport function isSessionStarted(session) {\n    return !isSessionInNotStartedState(session);\n}\nexport function isSessionInExpiredState(session) {\n    return session.isExpired !== undefined || !isActiveSession(session);\n}\n// An active session is a session in either `Tracked` or `NotTracked` state\nfunction isActiveSession(sessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return ((sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n        (sessionState.expire === undefined || dateNow() < Number(sessionState.expire)));\n}\nexport function expandSessionState(session) {\n    session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY);\n}\nexport function toSessionString(session) {\n    return (objectEntries(session)\n        // we use `aid` as a key for anonymousId\n        .map(([key, value]) => (key === 'anonymousId' ? `aid=${value}` : `${key}=${value}`))\n        .join(SESSION_ENTRY_SEPARATOR));\n}\nexport function toSessionState(sessionString) {\n    const session = {};\n    if (isValidSessionString(sessionString)) {\n        sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n            const matches = SESSION_ENTRY_REGEXP.exec(entry);\n            if (matches !== null) {\n                const [, key, value] = matches;\n                if (key === 'aid') {\n                    // we use `aid` as a key for anonymousId\n                    session.anonymousId = value;\n                }\n                else {\n                    session[key] = value;\n                }\n            }\n        });\n    }\n    return session;\n}\n//# sourceMappingURL=sessionState.js.map","import { isChromium } from '../../../tools/utils/browserDetection';\nimport { getCurrentSite, areCookiesAuthorized, getCookie, setCookie } from '../../../browser/cookie';\nimport { tryOldCookiesMigration } from '../oldCookiesMigration';\nimport { SESSION_COOKIE_EXPIRATION_DELAY, SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY, SessionPersistence, } from '../sessionConstants';\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState';\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy';\nexport function selectCookieStrategy(initConfiguration) {\n    const cookieOptions = buildCookieOptions(initConfiguration);\n    return areCookiesAuthorized(cookieOptions) ? { type: SessionPersistence.COOKIE, cookieOptions } : undefined;\n}\nexport function initCookieStrategy(configuration, cookieOptions) {\n    const cookieStore = {\n        /**\n         * Lock strategy allows mitigating issues due to concurrent access to cookie.\n         * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n         */\n        isLockEnabled: isChromium(),\n        persistSession: persistSessionCookie(cookieOptions),\n        retrieveSession: retrieveSessionCookie,\n        expireSession: (sessionState) => expireSessionCookie(cookieOptions, sessionState, configuration),\n    };\n    tryOldCookiesMigration(cookieStore);\n    return cookieStore;\n}\nfunction persistSessionCookie(options) {\n    return (session) => {\n        setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options);\n    };\n}\nfunction expireSessionCookie(options, sessionState, configuration) {\n    const expiredSessionState = getExpiredSessionState(sessionState, configuration);\n    // we do not extend cookie expiration date\n    setCookie(SESSION_STORE_KEY, toSessionString(expiredSessionState), configuration.trackAnonymousUser ? SESSION_COOKIE_EXPIRATION_DELAY : SESSION_TIME_OUT_DELAY, options);\n}\nfunction retrieveSessionCookie() {\n    const sessionString = getCookie(SESSION_STORE_KEY);\n    const sessionState = toSessionState(sessionString);\n    return sessionState;\n}\nexport function buildCookieOptions(initConfiguration) {\n    const cookieOptions = {};\n    cookieOptions.secure =\n        !!initConfiguration.useSecureSessionCookie || !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    cookieOptions.crossSite = !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    if (initConfiguration.trackSessionAcrossSubdomains) {\n        cookieOptions.domain = getCurrentSite();\n    }\n    return cookieOptions;\n}\n//# sourceMappingURL=sessionInCookie.js.map","import { generateUUID } from '../../../tools/utils/stringUtils';\nimport { SessionPersistence } from '../sessionConstants';\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState';\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy';\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_';\nexport function selectLocalStorageStrategy() {\n    try {\n        const id = generateUUID();\n        const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`;\n        localStorage.setItem(testKey, id);\n        const retrievedId = localStorage.getItem(testKey);\n        localStorage.removeItem(testKey);\n        return id === retrievedId ? { type: SessionPersistence.LOCAL_STORAGE } : undefined;\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\nexport function initLocalStorageStrategy(configuration) {\n    return {\n        isLockEnabled: false,\n        persistSession: persistInLocalStorage,\n        retrieveSession: retrieveSessionFromLocalStorage,\n        expireSession: (sessionState) => expireSessionFromLocalStorage(sessionState, configuration),\n    };\n}\nfunction persistInLocalStorage(sessionState) {\n    localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState));\n}\nfunction retrieveSessionFromLocalStorage() {\n    const sessionString = localStorage.getItem(SESSION_STORE_KEY);\n    return toSessionState(sessionString);\n}\nfunction expireSessionFromLocalStorage(previousSessionState, configuration) {\n    persistInLocalStorage(getExpiredSessionState(previousSessionState, configuration));\n}\n//# sourceMappingURL=sessionInLocalStorage.js.map","import { setTimeout } from '../../tools/timer';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { expandSessionState, isSessionInExpiredState } from './sessionState';\nexport const LOCK_RETRY_DELAY = 10;\nexport const LOCK_MAX_TRIES = 100;\nconst bufferedOperations = [];\nlet ongoingOperations;\nexport function processSessionStoreOperations(operations, sessionStoreStrategy, numberOfRetries = 0) {\n    var _a;\n    const { isLockEnabled, persistSession, expireSession } = sessionStoreStrategy;\n    const persistWithLock = (session) => persistSession({ ...session, lock: currentLock });\n    const retrieveStore = () => {\n        const session = sessionStoreStrategy.retrieveSession();\n        const lock = session.lock;\n        if (session.lock) {\n            delete session.lock;\n        }\n        return {\n            session,\n            lock,\n        };\n    };\n    if (!ongoingOperations) {\n        ongoingOperations = operations;\n    }\n    if (operations !== ongoingOperations) {\n        bufferedOperations.push(operations);\n        return;\n    }\n    if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n        next(sessionStoreStrategy);\n        return;\n    }\n    let currentLock;\n    let currentStore = retrieveStore();\n    if (isLockEnabled) {\n        // if someone has lock, retry later\n        if (currentStore.lock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n        // acquire lock\n        currentLock = generateUUID();\n        persistWithLock(currentStore.session);\n        // if lock is not acquired, retry later\n        currentStore = retrieveStore();\n        if (currentStore.lock !== currentLock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n    }\n    let processedSession = operations.process(currentStore.session);\n    if (isLockEnabled) {\n        // if lock corrupted after process, retry later\n        currentStore = retrieveStore();\n        if (currentStore.lock !== currentLock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n    }\n    if (processedSession) {\n        if (isSessionInExpiredState(processedSession)) {\n            expireSession(processedSession);\n        }\n        else {\n            expandSessionState(processedSession);\n            if (isLockEnabled) {\n                persistWithLock(processedSession);\n            }\n            else {\n                persistSession(processedSession);\n            }\n        }\n    }\n    if (isLockEnabled) {\n        // correctly handle lock around expiration would require to handle this case properly at several levels\n        // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n        if (!(processedSession && isSessionInExpiredState(processedSession))) {\n            // if lock corrupted after persist, retry later\n            currentStore = retrieveStore();\n            if (currentStore.lock !== currentLock) {\n                retryLater(operations, sessionStoreStrategy, numberOfRetries);\n                return;\n            }\n            persistSession(currentStore.session);\n            processedSession = currentStore.session;\n        }\n    }\n    // call after even if session is not persisted in order to perform operations on\n    // up-to-date session state value => the value could have been modified by another tab\n    (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentStore.session);\n    next(sessionStoreStrategy);\n}\nfunction retryLater(operations, sessionStore, currentNumberOfRetries) {\n    setTimeout(() => {\n        processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1);\n    }, LOCK_RETRY_DELAY);\n}\nfunction next(sessionStore) {\n    ongoingOperations = undefined;\n    const nextOperations = bufferedOperations.shift();\n    if (nextOperations) {\n        processSessionStoreOperations(nextOperations, sessionStore);\n    }\n}\n//# sourceMappingURL=sessionStoreOperations.js.map","import { clearInterval, setInterval } from '../../tools/timer';\nimport { Observable } from '../../tools/observable';\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { display } from '../../tools/display';\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie';\nimport { getExpiredSessionState, isSessionInExpiredState, isSessionInNotStartedState, isSessionStarted, } from './sessionState';\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage';\nimport { processSessionStoreOperations } from './sessionStoreOperations';\nimport { SessionPersistence } from './sessionConstants';\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND;\n/**\n * Selects the correct session store strategy type based on the configuration and storage\n * availability.\n */\nexport function selectSessionStoreStrategyType(initConfiguration) {\n    switch (initConfiguration.sessionPersistence) {\n        case SessionPersistence.COOKIE:\n            return selectCookieStrategy(initConfiguration);\n        case SessionPersistence.LOCAL_STORAGE:\n            return selectLocalStorageStrategy();\n        case undefined: {\n            let sessionStoreStrategyType = selectCookieStrategy(initConfiguration);\n            if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n                sessionStoreStrategyType = selectLocalStorageStrategy();\n            }\n            return sessionStoreStrategyType;\n        }\n        default:\n            display.error(`Invalid session persistence '${String(initConfiguration.sessionPersistence)}'`);\n    }\n}\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore(sessionStoreStrategyType, configuration, productKey, computeSessionState) {\n    const renewObservable = new Observable();\n    const expireObservable = new Observable();\n    const sessionStateUpdateObservable = new Observable();\n    const sessionStoreStrategy = sessionStoreStrategyType.type === SessionPersistence.COOKIE\n        ? initCookieStrategy(configuration, sessionStoreStrategyType.cookieOptions)\n        : initLocalStorageStrategy(configuration);\n    const { expireSession } = sessionStoreStrategy;\n    const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY);\n    let sessionCache;\n    startSession();\n    const { throttled: throttledExpandOrRenewSession, cancel: cancelExpandOrRenewSession } = throttle(() => {\n        processSessionStoreOperations({\n            process: (sessionState) => {\n                if (isSessionInNotStartedState(sessionState)) {\n                    return;\n                }\n                const synchronizedSession = synchronizeSession(sessionState);\n                expandOrRenewSessionState(synchronizedSession);\n                return synchronizedSession;\n            },\n            after: (sessionState) => {\n                if (isSessionStarted(sessionState) && !hasSessionInCache()) {\n                    renewSessionInCache(sessionState);\n                }\n                sessionCache = sessionState;\n            },\n        }, sessionStoreStrategy);\n    }, STORAGE_POLL_DELAY);\n    function expandSession() {\n        processSessionStoreOperations({\n            process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n        }, sessionStoreStrategy);\n    }\n    /**\n     * allows two behaviors:\n     * - if the session is active, synchronize the session cache without updating the session store\n     * - if the session is not active, clear the session store and expire the session cache\n     */\n    function watchSession() {\n        processSessionStoreOperations({\n            process: (sessionState) => isSessionInExpiredState(sessionState) ? getExpiredSessionState(sessionState, configuration) : undefined,\n            after: synchronizeSession,\n        }, sessionStoreStrategy);\n    }\n    function synchronizeSession(sessionState) {\n        if (isSessionInExpiredState(sessionState)) {\n            sessionState = getExpiredSessionState(sessionState, configuration);\n        }\n        if (hasSessionInCache()) {\n            if (isSessionInCacheOutdated(sessionState)) {\n                expireSessionInCache();\n            }\n            else {\n                sessionStateUpdateObservable.notify({ previousState: sessionCache, newState: sessionState });\n                sessionCache = sessionState;\n            }\n        }\n        return sessionState;\n    }\n    function startSession() {\n        processSessionStoreOperations({\n            process: (sessionState) => {\n                if (isSessionInNotStartedState(sessionState)) {\n                    return getExpiredSessionState(sessionState, configuration);\n                }\n            },\n            after: (sessionState) => {\n                sessionCache = sessionState;\n            },\n        }, sessionStoreStrategy);\n    }\n    function expandOrRenewSessionState(sessionState) {\n        if (isSessionInNotStartedState(sessionState)) {\n            return false;\n        }\n        const { trackingType, isTracked } = computeSessionState(sessionState[productKey]);\n        sessionState[productKey] = trackingType;\n        delete sessionState.isExpired;\n        if (isTracked && !sessionState.id) {\n            sessionState.id = generateUUID();\n            sessionState.created = String(dateNow());\n        }\n    }\n    function hasSessionInCache() {\n        return sessionCache[productKey] !== undefined;\n    }\n    function isSessionInCacheOutdated(sessionState) {\n        return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey];\n    }\n    function expireSessionInCache() {\n        sessionCache = getExpiredSessionState(sessionCache, configuration);\n        expireObservable.notify();\n    }\n    function renewSessionInCache(sessionState) {\n        sessionCache = sessionState;\n        renewObservable.notify();\n    }\n    function updateSessionState(partialSessionState) {\n        processSessionStoreOperations({\n            process: (sessionState) => ({ ...sessionState, ...partialSessionState }),\n            after: synchronizeSession,\n        }, sessionStoreStrategy);\n    }\n    return {\n        expandOrRenewSession: throttledExpandOrRenewSession,\n        expandSession,\n        getSession: () => sessionCache,\n        renewObservable,\n        expireObservable,\n        sessionStateUpdateObservable,\n        restartSession: startSession,\n        expire: () => {\n            cancelExpandOrRenewSession();\n            expireSession(sessionCache);\n            synchronizeSession(getExpiredSessionState(sessionCache, configuration));\n        },\n        stop: () => {\n            clearInterval(watchSessionTimeoutId);\n        },\n        updateSessionState,\n    };\n}\n//# sourceMappingURL=sessionStore.js.map","import { getInitCookie } from '../../browser/cookie';\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy';\nimport { expandSessionState, isSessionStarted } from './sessionState';\nexport const OLD_SESSION_COOKIE_NAME = '_dd';\nexport const OLD_RUM_COOKIE_NAME = '_dd_r';\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l';\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum';\nexport const LOGS_SESSION_KEY = 'logs';\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy) {\n    const sessionString = getInitCookie(SESSION_STORE_KEY);\n    if (!sessionString) {\n        const oldSessionId = getInitCookie(OLD_SESSION_COOKIE_NAME);\n        const oldRumType = getInitCookie(OLD_RUM_COOKIE_NAME);\n        const oldLogsType = getInitCookie(OLD_LOGS_COOKIE_NAME);\n        const session = {};\n        if (oldSessionId) {\n            session.id = oldSessionId;\n        }\n        if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n            session[LOGS_SESSION_KEY] = oldLogsType;\n        }\n        if (oldRumType && /^[012]$/.test(oldRumType)) {\n            session[RUM_SESSION_KEY] = oldRumType;\n        }\n        if (isSessionStarted(session)) {\n            expandSessionState(session);\n            cookieStoreStrategy.persistSession(session);\n        }\n    }\n}\n//# sourceMappingURL=oldCookiesMigration.js.map","import { timeStampNow } from '../../tools/utils/timeUtils';\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { INTAKE_SITE_US1, INTAKE_SITE_FED_STAGING, PCI_INTAKE_HOST_US1 } from './intakeSites';\nexport function createEndpointBuilder(initConfiguration, trackType, configurationTags) {\n    const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, trackType);\n    return {\n        build(api, payload) {\n            const parameters = buildEndpointParameters(initConfiguration, trackType, configurationTags, api, payload);\n            return buildUrlWithParameters(parameters);\n        },\n        urlPrefix: buildUrlWithParameters(''),\n        trackType,\n    };\n}\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(initConfiguration, trackType) {\n    const path = `/api/v2/${trackType}`;\n    const proxy = initConfiguration.proxy;\n    if (typeof proxy === 'string') {\n        const normalizedProxyUrl = normalizeUrl(proxy);\n        return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`;\n    }\n    if (typeof proxy === 'function') {\n        return (parameters) => proxy({ path, parameters });\n    }\n    const host = buildEndpointHost(trackType, initConfiguration);\n    return (parameters) => `https://${host}${path}?${parameters}`;\n}\nfunction buildEndpointHost(trackType, initConfiguration) {\n    const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration;\n    if (trackType === 'logs' && initConfiguration.usePciIntake && site === INTAKE_SITE_US1) {\n        return PCI_INTAKE_HOST_US1;\n    }\n    if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n        return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`;\n    }\n    if (site === INTAKE_SITE_FED_STAGING) {\n        return `http-intake.logs.${site}`;\n    }\n    const domainParts = site.split('.');\n    const extension = domainParts.pop();\n    return `browser-intake-${domainParts.join('-')}.${extension}`;\n}\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters({ clientToken, internalAnalyticsSubdomain }, trackType, configurationTags, api, { retry, encoding }) {\n    const tags = [`sdk_version:${\"6.0.0\"}`, `api:${api}`].concat(configurationTags);\n    if (retry) {\n        tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`);\n    }\n    const parameters = [\n        'ddsource=browser',\n        `ddtags=${encodeURIComponent(tags.join(','))}`,\n        `dd-api-key=${clientToken}`,\n        `dd-evp-origin-version=${encodeURIComponent(\"6.0.0\")}`,\n        'dd-evp-origin=browser',\n        `dd-request-id=${generateUUID()}`,\n    ];\n    if (encoding) {\n        parameters.push(`dd-evp-encoding=${encoding}`);\n    }\n    if (trackType === 'rum') {\n        parameters.push(`batch_time=${timeStampNow()}`);\n    }\n    if (internalAnalyticsSubdomain) {\n        parameters.reverse();\n    }\n    return parameters.join('&');\n}\n//# sourceMappingURL=endpointBuilder.js.map","import { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display';\nexport const TAG_SIZE_LIMIT = 200;\nexport function buildTags(configuration) {\n    const { env, service, version, datacenter } = configuration;\n    const tags = [];\n    if (env) {\n        tags.push(buildTag('env', env));\n    }\n    if (service) {\n        tags.push(buildTag('service', service));\n    }\n    if (version) {\n        tags.push(buildTag('version', version));\n    }\n    if (datacenter) {\n        tags.push(buildTag('datacenter', datacenter));\n    }\n    return tags;\n}\nexport function buildTag(key, rawValue) {\n    // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n    // that the backend may not follow the exact same rules, so we only want to display an informal\n    // warning.\n    const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1;\n    if (rawValue.length > valueSizeLimit || hasForbiddenCharacters(rawValue)) {\n        display.warn(`${key} value doesn't meet tag requirements and will be sanitized. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/tagging/#defining-tags`);\n    }\n    // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n    // by forging a value containing commas.\n    const sanitizedValue = rawValue.replace(/,/g, '_');\n    return `${key}:${sanitizedValue}`;\n}\nfunction hasForbiddenCharacters(rawValue) {\n    // Unicode property escapes is not supported in all browsers, so we use a try/catch.\n    // Todo: Remove the try/catch when dropping support for Chrome 63 and Firefox 67\n    // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#browser_compatibility\n    if (!supportUnicodePropertyEscapes()) {\n        return false;\n    }\n    // We use the Unicode property escapes to match any character that is a letter including other languages like Chinese, Japanese, etc.\n    // p{Ll} matches a lowercase letter.\n    // p{Lo} matches a letter that is neither uppercase nor lowercase (ex: Japanese characters).\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#unicode_property_escapes_vs._character_classes\n    return new RegExp('[^\\\\p{Ll}\\\\p{Lo}0-9_:./-]', 'u').test(rawValue);\n}\nexport function supportUnicodePropertyEscapes() {\n    try {\n        new RegExp('[\\\\p{Ll}]', 'u');\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n//# sourceMappingURL=tags.js.map","import { createEndpointBuilder } from './endpointBuilder';\nimport { buildTags } from './tags';\nimport { INTAKE_SITE_US1, INTAKE_URL_PARAMETERS } from './intakeSites';\nexport function computeTransportConfiguration(initConfiguration) {\n    const site = initConfiguration.site || INTAKE_SITE_US1;\n    const tags = buildTags(initConfiguration);\n    const endpointBuilders = computeEndpointBuilders(initConfiguration, tags);\n    const replicaConfiguration = computeReplicaConfiguration(initConfiguration, tags);\n    return {\n        replica: replicaConfiguration,\n        site,\n        ...endpointBuilders,\n    };\n}\nfunction computeEndpointBuilders(initConfiguration, tags) {\n    return {\n        logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n        rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n        sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'replay', tags),\n    };\n}\nfunction computeReplicaConfiguration(initConfiguration, tags) {\n    if (!initConfiguration.replica) {\n        return;\n    }\n    const replicaConfiguration = {\n        ...initConfiguration,\n        site: INTAKE_SITE_US1,\n        clientToken: initConfiguration.replica.clientToken,\n    };\n    const replicaEndpointBuilders = {\n        logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n        rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n    };\n    return { applicationId: initConfiguration.replica.applicationId, ...replicaEndpointBuilders };\n}\nexport function isIntakeUrl(url) {\n    // check if tags is present in the query string\n    return INTAKE_URL_PARAMETERS.every((param) => url.includes(param));\n}\n//# sourceMappingURL=transportConfiguration.js.map","import { catchUserErrors } from '../../tools/catchUserErrors';\nimport { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display';\nimport { ONE_SECOND } from '../../tools/utils/timeUtils';\nimport { isPercentage } from '../../tools/utils/numberUtils';\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils';\nimport { objectHasValue } from '../../tools/utils/objectUtils';\nimport { selectSessionStoreStrategyType } from '../session/sessionStore';\nimport { TrackingConsent } from '../trackingConsent';\nimport { computeTransportConfiguration } from './transportConfiguration';\nexport const DefaultPrivacyLevel = {\n    ALLOW: 'allow',\n    MASK: 'mask',\n    MASK_USER_INPUT: 'mask-user-input',\n};\nexport const TraceContextInjection = {\n    ALL: 'all',\n    SAMPLED: 'sampled',\n};\nfunction isString(tag, tagName) {\n    if (tag !== undefined && tag !== null && typeof tag !== 'string') {\n        display.error(`${tagName} must be defined as a string`);\n        return false;\n    }\n    return true;\n}\nfunction isDatadogSite(site) {\n    if (site && typeof site === 'string' && !/(datadog|ddog|datad0g|dd0g)/.test(site)) {\n        display.error(`Site should be a valid Datadog site. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/site/.`);\n        return false;\n    }\n    return true;\n}\nexport function isSampleRate(sampleRate, name) {\n    if (sampleRate !== undefined && !isPercentage(sampleRate)) {\n        display.error(`${name} Sample Rate should be a number between 0 and 100`);\n        return false;\n    }\n    return true;\n}\nexport function validateAndBuildConfiguration(initConfiguration) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!initConfiguration || !initConfiguration.clientToken) {\n        display.error('Client Token is not configured, we will not send any data.');\n        return;\n    }\n    if (!isDatadogSite(initConfiguration.site) ||\n        !isSampleRate(initConfiguration.sessionSampleRate, 'Session') ||\n        !isSampleRate(initConfiguration.telemetrySampleRate, 'Telemetry') ||\n        !isSampleRate(initConfiguration.telemetryConfigurationSampleRate, 'Telemetry Configuration') ||\n        !isSampleRate(initConfiguration.telemetryUsageSampleRate, 'Telemetry Usage') ||\n        !isString(initConfiguration.version, 'Version') ||\n        !isString(initConfiguration.env, 'Env') ||\n        !isString(initConfiguration.service, 'Service')) {\n        return;\n    }\n    if (initConfiguration.trackingConsent !== undefined &&\n        !objectHasValue(TrackingConsent, initConfiguration.trackingConsent)) {\n        display.error('Tracking Consent should be either \"granted\" or \"not-granted\"');\n        return;\n    }\n    return {\n        beforeSend: initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n        sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n        sessionSampleRate: (_a = initConfiguration.sessionSampleRate) !== null && _a !== void 0 ? _a : 100,\n        telemetrySampleRate: (_b = initConfiguration.telemetrySampleRate) !== null && _b !== void 0 ? _b : 20,\n        telemetryConfigurationSampleRate: (_c = initConfiguration.telemetryConfigurationSampleRate) !== null && _c !== void 0 ? _c : 5,\n        telemetryUsageSampleRate: (_d = initConfiguration.telemetryUsageSampleRate) !== null && _d !== void 0 ? _d : 5,\n        service: initConfiguration.service || undefined,\n        silentMultipleInit: !!initConfiguration.silentMultipleInit,\n        allowUntrustedEvents: !!initConfiguration.allowUntrustedEvents,\n        trackingConsent: (_e = initConfiguration.trackingConsent) !== null && _e !== void 0 ? _e : TrackingConsent.GRANTED,\n        trackAnonymousUser: (_f = initConfiguration.trackAnonymousUser) !== null && _f !== void 0 ? _f : true,\n        storeContextsAcrossPages: !!initConfiguration.storeContextsAcrossPages,\n        /**\n         * beacon payload max queue size implementation is 64kb\n         * ensure that we leave room for logs, rum and potential other users\n         */\n        batchBytesLimit: 16 * ONE_KIBI_BYTE,\n        eventRateLimiterThreshold: 3000,\n        maxTelemetryEventsPerPage: 15,\n        /**\n         * flush automatically, aim to be lower than ALB connection timeout\n         * to maximize connection reuse.\n         */\n        flushTimeout: (30 * ONE_SECOND),\n        /**\n         * Logs intake limit\n         */\n        batchMessagesLimit: 50,\n        messageBytesLimit: 256 * ONE_KIBI_BYTE,\n        ...computeTransportConfiguration(initConfiguration),\n    };\n}\nexport function serializeConfiguration(initConfiguration) {\n    return {\n        session_sample_rate: initConfiguration.sessionSampleRate,\n        telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n        telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n        telemetry_usage_sample_rate: initConfiguration.telemetryUsageSampleRate,\n        use_before_send: !!initConfiguration.beforeSend,\n        use_partitioned_cross_site_session_cookie: initConfiguration.usePartitionedCrossSiteSessionCookie,\n        use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n        use_proxy: !!initConfiguration.proxy,\n        silent_multiple_init: initConfiguration.silentMultipleInit,\n        track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n        track_anonymous_user: initConfiguration.trackAnonymousUser,\n        session_persistence: initConfiguration.sessionPersistence,\n        allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n        store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n        allow_untrusted_events: !!initConfiguration.allowUntrustedEvents,\n        tracking_consent: initConfiguration.trackingConsent,\n    };\n}\n//# sourceMappingURL=configuration.js.map","import { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { monitor } from '../../tools/monitor';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { addEventListener } from '../../browser/addEventListener';\nimport { safeTruncate } from '../../tools/utils/stringUtils';\nimport { ErrorSource } from '../error/error.types';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nexport const RawReportType = {\n    intervention: 'intervention',\n    deprecation: 'deprecation',\n    cspViolation: 'csp_violation',\n};\nexport function initReportObservable(configuration, apis) {\n    const observables = [];\n    if (apis.includes(RawReportType.cspViolation)) {\n        observables.push(createCspViolationReportObservable(configuration));\n    }\n    const reportTypes = apis.filter((api) => api !== RawReportType.cspViolation);\n    if (reportTypes.length) {\n        observables.push(createReportObservable(reportTypes));\n    }\n    return mergeObservables(...observables);\n}\nfunction createReportObservable(reportTypes) {\n    return new Observable((observable) => {\n        if (!window.ReportingObserver) {\n            return;\n        }\n        const handleReports = monitor((reports, _) => reports.forEach((report) => observable.notify(buildRawReportErrorFromReport(report))));\n        const observer = new window.ReportingObserver(handleReports, {\n            types: reportTypes,\n            buffered: true,\n        });\n        observer.observe();\n        return () => {\n            observer.disconnect();\n        };\n    });\n}\nfunction createCspViolationReportObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop } = addEventListener(configuration, document, \"securitypolicyviolation\" /* DOM_EVENT.SECURITY_POLICY_VIOLATION */, (event) => {\n            observable.notify(buildRawReportErrorFromCspViolation(event));\n        });\n        return stop;\n    });\n}\nfunction buildRawReportErrorFromReport(report) {\n    const { type, body } = report;\n    return buildRawReportError({\n        type: body.id,\n        message: `${type}: ${body.message}`,\n        originalError: report,\n        stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n    });\n}\nfunction buildRawReportErrorFromCspViolation(event) {\n    const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`;\n    return buildRawReportError({\n        type: event.effectiveDirective,\n        message: `${RawReportType.cspViolation}: ${message}`,\n        originalError: event,\n        csp: {\n            disposition: event.disposition,\n        },\n        stack: buildStack(event.effectiveDirective, event.originalPolicy\n            ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n            : 'no policy', event.sourceFile, event.lineNumber, event.columnNumber),\n    });\n}\nfunction buildRawReportError(partial) {\n    return {\n        startClocks: clocksNow(),\n        source: ErrorSource.REPORT,\n        handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n        ...partial,\n    };\n}\nfunction buildStack(name, message, sourceFile, lineNumber, columnNumber) {\n    return sourceFile\n        ? toStackTraceString({\n            name,\n            message,\n            stack: [\n                {\n                    func: '?',\n                    url: sourceFile,\n                    line: lineNumber !== null && lineNumber !== void 0 ? lineNumber : undefined,\n                    column: columnNumber !== null && columnNumber !== void 0 ? columnNumber : undefined,\n                },\n            ],\n        })\n        : undefined;\n}\n//# sourceMappingURL=reportObservable.js.map","import { serializeConfiguration, ONE_KIBI_BYTE, validateAndBuildConfiguration, display, removeDuplicates, ConsoleApiName, RawReportType, objectValues, } from '@datadog/browser-core';\n/**\n * arbitrary value, byte precision not needed\n */\nexport const DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * ONE_KIBI_BYTE;\nexport function validateAndBuildLogsConfiguration(initConfiguration) {\n    if (initConfiguration.usePciIntake === true && initConfiguration.site && initConfiguration.site !== 'datadoghq.com') {\n        display.warn('PCI compliance for Logs is only available for Datadog organizations in the US1 site. Default intake will be used.');\n    }\n    const baseConfiguration = validateAndBuildConfiguration(initConfiguration);\n    const forwardConsoleLogs = validateAndBuildForwardOption(initConfiguration.forwardConsoleLogs, objectValues(ConsoleApiName), 'Forward Console Logs');\n    const forwardReports = validateAndBuildForwardOption(initConfiguration.forwardReports, objectValues(RawReportType), 'Forward Reports');\n    if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {\n        return;\n    }\n    if (initConfiguration.forwardErrorsToLogs && !forwardConsoleLogs.includes(ConsoleApiName.error)) {\n        forwardConsoleLogs.push(ConsoleApiName.error);\n    }\n    return {\n        forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,\n        forwardConsoleLogs,\n        forwardReports,\n        requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT,\n        ...baseConfiguration,\n    };\n}\nexport function validateAndBuildForwardOption(option, allowedValues, label) {\n    if (option === undefined) {\n        return [];\n    }\n    if (!(option === 'all' || (Array.isArray(option) && option.every((api) => allowedValues.includes(api))))) {\n        display.error(`${label} should be \"all\" or an array with allowed values \"${allowedValues.join('\", \"')}\"`);\n        return;\n    }\n    return option === 'all' ? allowedValues : removeDuplicates(option);\n}\nexport function serializeLogsConfiguration(configuration) {\n    const baseSerializedInitConfiguration = serializeConfiguration(configuration);\n    return {\n        forward_errors_to_logs: configuration.forwardErrorsToLogs,\n        forward_console_logs: configuration.forwardConsoleLogs,\n        forward_reports: configuration.forwardReports,\n        use_pci_intake: configuration.usePciIntake,\n        ...baseSerializedInitConfiguration,\n    };\n}\n//# sourceMappingURL=configuration.js.map","import { createBoundedBuffer, canUseEventBridge, display, displayAlreadyInitializedError, initFeatureFlags, initFetchObservable, noop, timeStampNow, } from '@datadog/browser-core';\nimport { validateAndBuildLogsConfiguration, } from '../domain/configuration';\nexport function createPreStartStrategy(getCommonContext, trackingConsentState, doStartLogs) {\n    const bufferApiCalls = createBoundedBuffer();\n    let cachedInitConfiguration;\n    let cachedConfiguration;\n    const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartLogs);\n    function tryStartLogs() {\n        if (!cachedConfiguration || !cachedInitConfiguration || !trackingConsentState.isGranted()) {\n            return;\n        }\n        trackingConsentStateSubscription.unsubscribe();\n        const startLogsResult = doStartLogs(cachedInitConfiguration, cachedConfiguration);\n        bufferApiCalls.drain(startLogsResult);\n    }\n    return {\n        init(initConfiguration) {\n            if (!initConfiguration) {\n                display.error('Missing configuration');\n                return;\n            }\n            // Set the experimental feature flags as early as possible, so we can use them in most places\n            initFeatureFlags(initConfiguration.enableExperimentalFeatures);\n            if (canUseEventBridge()) {\n                initConfiguration = overrideInitConfigurationForBridge(initConfiguration);\n            }\n            // Expose the initial configuration regardless of initialization success.\n            cachedInitConfiguration = initConfiguration;\n            if (cachedConfiguration) {\n                displayAlreadyInitializedError('DD_LOGS', initConfiguration);\n                return;\n            }\n            const configuration = validateAndBuildLogsConfiguration(initConfiguration);\n            if (!configuration) {\n                return;\n            }\n            cachedConfiguration = configuration;\n            // Instrumuent fetch to track network requests\n            // This is needed in case the consent is not granted and some cutsomer\n            // library (Apollo Client) is storing uninstrumented fetch to be used later\n            // The subscrption is needed so that the instrumentation process is completed\n            initFetchObservable().subscribe(noop);\n            trackingConsentState.tryToInit(configuration.trackingConsent);\n            tryStartLogs();\n        },\n        get initConfiguration() {\n            return cachedInitConfiguration;\n        },\n        getInternalContext: noop,\n        handleLog(message, statusType, handlingStack, context = getCommonContext(), date = timeStampNow()) {\n            bufferApiCalls.add((startLogsResult) => startLogsResult.handleLog(message, statusType, handlingStack, context, date));\n        },\n    };\n}\nfunction overrideInitConfigurationForBridge(initConfiguration) {\n    return { ...initConfiguration, clientToken: 'empty' };\n}\n//# sourceMappingURL=preStartLogs.js.map","import { addTelemetryUsage, createContextManager, makePublicApi, monitor, checkUser, sanitizeUser, sanitize, createCustomerDataTrackerManager, storeContextManager, displayAlreadyInitializedError, deepClone, createTrackingConsentState, } from '@datadog/browser-core';\nimport { Logger } from '../domain/logger';\nimport { buildCommonContext } from '../domain/contexts/commonContext';\nimport { createPreStartStrategy } from './preStartLogs';\nconst LOGS_STORAGE_KEY = 'logs';\nexport function makeLogsPublicApi(startLogsImpl) {\n    const customerDataTrackerManager = createCustomerDataTrackerManager();\n    const globalContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */));\n    const userContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */));\n    const trackingConsentState = createTrackingConsentState();\n    function getCommonContext() {\n        return buildCommonContext(globalContextManager, userContextManager);\n    }\n    let strategy = createPreStartStrategy(getCommonContext, trackingConsentState, (initConfiguration, configuration) => {\n        if (initConfiguration.storeContextsAcrossPages) {\n            storeContextManager(configuration, globalContextManager, LOGS_STORAGE_KEY, 2 /* CustomerDataType.GlobalContext */);\n            storeContextManager(configuration, userContextManager, LOGS_STORAGE_KEY, 1 /* CustomerDataType.User */);\n        }\n        const startLogsResult = startLogsImpl(initConfiguration, configuration, getCommonContext, trackingConsentState);\n        strategy = createPostStartStrategy(initConfiguration, startLogsResult);\n        return startLogsResult;\n    });\n    const customLoggers = {};\n    const mainLogger = new Logger((...params) => strategy.handleLog(...params), customerDataTrackerManager.createDetachedTracker());\n    return makePublicApi({\n        logger: mainLogger,\n        init: monitor((initConfiguration) => strategy.init(initConfiguration)),\n        setTrackingConsent: monitor((trackingConsent) => {\n            trackingConsentState.update(trackingConsent);\n            addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent });\n        }),\n        getGlobalContext: monitor(() => globalContextManager.getContext()),\n        setGlobalContext: monitor((context) => globalContextManager.setContext(context)),\n        setGlobalContextProperty: monitor((key, value) => globalContextManager.setContextProperty(key, value)),\n        removeGlobalContextProperty: monitor((key) => globalContextManager.removeContextProperty(key)),\n        clearGlobalContext: monitor(() => globalContextManager.clearContext()),\n        createLogger: monitor((name, conf = {}) => {\n            customLoggers[name] = new Logger((...params) => strategy.handleLog(...params), customerDataTrackerManager.createDetachedTracker(), sanitize(name), conf.handler, conf.level, sanitize(conf.context));\n            return customLoggers[name];\n        }),\n        getLogger: monitor((name) => customLoggers[name]),\n        getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),\n        getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),\n        setUser: monitor((newUser) => {\n            if (checkUser(newUser)) {\n                userContextManager.setContext(sanitizeUser(newUser));\n            }\n        }),\n        getUser: monitor(() => userContextManager.getContext()),\n        setUserProperty: monitor((key, property) => {\n            const sanitizedProperty = sanitizeUser({ [key]: property })[key];\n            userContextManager.setContextProperty(key, sanitizedProperty);\n        }),\n        removeUserProperty: monitor((key) => userContextManager.removeContextProperty(key)),\n        clearUser: monitor(() => userContextManager.clearContext()),\n    });\n}\nfunction createPostStartStrategy(initConfiguration, startLogsResult) {\n    return {\n        init: (initConfiguration) => {\n            displayAlreadyInitializedError('DD_LOGS', initConfiguration);\n        },\n        initConfiguration,\n        ...startLogsResult,\n    };\n}\n//# sourceMappingURL=logsPublicApi.js.map","import { Observable } from '../tools/observable';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { addEventListeners, addEventListener } from './addEventListener';\nexport const PageExitReason = {\n    HIDDEN: 'visibility_hidden',\n    UNLOADING: 'before_unload',\n    PAGEHIDE: 'page_hide',\n    FROZEN: 'page_frozen',\n};\nexport function createPageExitObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop: stopListeners } = addEventListeners(configuration, window, [\"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, \"freeze\" /* DOM_EVENT.FREEZE */], (event) => {\n            if (event.type === \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */ && document.visibilityState === 'hidden') {\n                /**\n                 * Only event that guarantee to fire on mobile devices when the page transitions to background state\n                 * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n                 */\n                observable.notify({ reason: PageExitReason.HIDDEN });\n            }\n            else if (event.type === \"freeze\" /* DOM_EVENT.FREEZE */) {\n                /**\n                 * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n                 * Allow to collect events happening between hidden and frozen state.\n                 */\n                observable.notify({ reason: PageExitReason.FROZEN });\n            }\n        }, { capture: true });\n        const stopBeforeUnloadListener = addEventListener(configuration, window, \"beforeunload\" /* DOM_EVENT.BEFORE_UNLOAD */, () => {\n            observable.notify({ reason: PageExitReason.UNLOADING });\n        }).stop;\n        return () => {\n            stopListeners();\n            stopBeforeUnloadListener();\n        };\n    });\n}\nexport function isPageExitReason(reason) {\n    return objectValues(PageExitReason).includes(reason);\n}\n//# sourceMappingURL=pageExitObservable.js.map","import { getInitCookie } from '../../browser/cookie';\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id';\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id';\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum';\nexport function willSyntheticsInjectRum() {\n    return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));\n}\nexport function getSyntheticsTestId() {\n    const value = window._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\nexport function getSyntheticsResultId() {\n    const value = window._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\n//# sourceMappingURL=syntheticsWorkerValues.js.map","import { setInterval, clearInterval } from './timer';\nimport { removeItem } from './utils/arrayUtils';\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils';\nconst END_OF_TIMES = Infinity;\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;\nexport function createValueHistory({ expireDelay, maxEntries, }) {\n    let entries = [];\n    const clearOldValuesInterval = setInterval(() => clearOldValues(), CLEAR_OLD_VALUES_INTERVAL);\n    function clearOldValues() {\n        const oldTimeThreshold = relativeNow() - expireDelay;\n        while (entries.length > 0 && entries[entries.length - 1].endTime < oldTimeThreshold) {\n            entries.pop();\n        }\n    }\n    /**\n     * Add a value to the history associated with a start time. Returns a reference to this newly\n     * added entry that can be removed or closed.\n     */\n    function add(value, startTime) {\n        const entry = {\n            value,\n            startTime,\n            endTime: END_OF_TIMES,\n            remove: () => {\n                removeItem(entries, entry);\n            },\n            close: (endTime) => {\n                entry.endTime = endTime;\n            },\n        };\n        if (maxEntries && entries.length >= maxEntries) {\n            entries.pop();\n        }\n        entries.unshift(entry);\n        return entry;\n    }\n    /**\n     * Return the latest value that was active during `startTime`, or the currently active value\n     * if no `startTime` is provided. This method assumes that entries are not overlapping.\n     *\n     * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n     */\n    function find(startTime = END_OF_TIMES, options = { returnInactive: false }) {\n        for (const entry of entries) {\n            if (entry.startTime <= startTime) {\n                if (options.returnInactive || startTime <= entry.endTime) {\n                    return entry.value;\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Helper function to close the currently active value, if any. This method assumes that entries\n     * are not overlapping.\n     */\n    function closeActive(endTime) {\n        const latestEntry = entries[0];\n        if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n            latestEntry.close(endTime);\n        }\n    }\n    /**\n     * Return all values with an active period overlapping with the duration,\n     * or all values that were active during `startTime` if no duration is provided,\n     * or all currently active values if no `startTime` is provided.\n     */\n    function findAll(startTime = END_OF_TIMES, duration = 0) {\n        const endTime = addDuration(startTime, duration);\n        return entries\n            .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n            .map((entry) => entry.value);\n    }\n    /**\n     * Remove all entries from this collection.\n     */\n    function reset() {\n        entries = [];\n    }\n    /**\n     * Stop internal garbage collection of past entries.\n     */\n    function stop() {\n        clearInterval(clearOldValuesInterval);\n    }\n    return { add, find, closeActive, findAll, reset, stop };\n}\n//# sourceMappingURL=valueHistory.js.map","import { Observable } from '../../tools/observable';\nimport { createValueHistory } from '../../tools/valueHistory';\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { addEventListener, addEventListeners } from '../../browser/addEventListener';\nimport { clearInterval, setInterval } from '../../tools/timer';\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { startSessionStore } from './sessionStore';\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE;\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;\nlet stopCallbacks = [];\nexport function startSessionManager(configuration, productKey, computeSessionState, trackingConsentState) {\n    const renewObservable = new Observable();\n    const expireObservable = new Observable();\n    // TODO - Improve configuration type and remove assertion\n    const sessionStore = startSessionStore(configuration.sessionStoreStrategyType, configuration, productKey, computeSessionState);\n    stopCallbacks.push(() => sessionStore.stop());\n    const sessionContextHistory = createValueHistory({\n        expireDelay: SESSION_CONTEXT_TIMEOUT_DELAY,\n    });\n    stopCallbacks.push(() => sessionContextHistory.stop());\n    sessionStore.renewObservable.subscribe(() => {\n        sessionContextHistory.add(buildSessionContext(), relativeNow());\n        renewObservable.notify();\n    });\n    sessionStore.expireObservable.subscribe(() => {\n        expireObservable.notify();\n        sessionContextHistory.closeActive(relativeNow());\n    });\n    // We expand/renew session unconditionally as tracking consent is always granted when the session\n    // manager is started.\n    sessionStore.expandOrRenewSession();\n    sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);\n    trackingConsentState.observable.subscribe(() => {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n        else {\n            sessionStore.expire();\n        }\n    });\n    trackActivity(configuration, () => {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n    });\n    trackVisibility(configuration, () => sessionStore.expandSession());\n    trackResume(configuration, () => sessionStore.restartSession());\n    function buildSessionContext() {\n        return {\n            id: sessionStore.getSession().id,\n            trackingType: sessionStore.getSession()[productKey],\n            isReplayForced: !!sessionStore.getSession().forcedReplay,\n            anonymousId: sessionStore.getSession().anonymousId,\n        };\n    }\n    return {\n        findSession: (startTime, options) => sessionContextHistory.find(startTime, options),\n        renewObservable,\n        expireObservable,\n        sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n        expire: sessionStore.expire,\n        updateSessionState: sessionStore.updateSessionState,\n    };\n}\nexport function stopSessionManager() {\n    stopCallbacks.forEach((e) => e());\n    stopCallbacks = [];\n}\nfunction trackActivity(configuration, expandOrRenewSession) {\n    const { stop } = addEventListeners(configuration, window, [\"click\" /* DOM_EVENT.CLICK */, \"touchstart\" /* DOM_EVENT.TOUCH_START */, \"keydown\" /* DOM_EVENT.KEY_DOWN */, \"scroll\" /* DOM_EVENT.SCROLL */], expandOrRenewSession, { capture: true, passive: true });\n    stopCallbacks.push(stop);\n}\nfunction trackVisibility(configuration, expandSession) {\n    const expandSessionWhenVisible = () => {\n        if (document.visibilityState === 'visible') {\n            expandSession();\n        }\n    };\n    const { stop } = addEventListener(configuration, document, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, expandSessionWhenVisible);\n    stopCallbacks.push(stop);\n    const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);\n    stopCallbacks.push(() => {\n        clearInterval(visibilityCheckInterval);\n    });\n}\nfunction trackResume(configuration, cb) {\n    const { stop } = addEventListener(configuration, window, \"resume\" /* DOM_EVENT.RESUME */, cb, { capture: true });\n    stopCallbacks.push(stop);\n}\n//# sourceMappingURL=sessionManager.js.map","import { Observable, performDraw, startSessionManager } from '@datadog/browser-core';\nexport const LOGS_SESSION_KEY = 'logs';\nexport function startLogsSessionManager(configuration, trackingConsentState) {\n    const sessionManager = startSessionManager(configuration, LOGS_SESSION_KEY, (rawTrackingType) => computeSessionState(configuration, rawTrackingType), trackingConsentState);\n    return {\n        findTrackedSession: (startTime, options = { returnInactive: false }) => {\n            const session = sessionManager.findSession(startTime, options);\n            return session && session.trackingType === \"1\" /* LoggerTrackingType.TRACKED */\n                ? {\n                    id: session.id,\n                    anonymousId: session.anonymousId,\n                }\n                : undefined;\n        },\n        expireObservable: sessionManager.expireObservable,\n    };\n}\nexport function startLogsSessionManagerStub(configuration) {\n    const isTracked = computeTrackingType(configuration) === \"1\" /* LoggerTrackingType.TRACKED */;\n    const session = isTracked ? {} : undefined;\n    return {\n        findTrackedSession: () => session,\n        expireObservable: new Observable(),\n    };\n}\nfunction computeTrackingType(configuration) {\n    if (!performDraw(configuration.sessionSampleRate)) {\n        return \"0\" /* LoggerTrackingType.NOT_TRACKED */;\n    }\n    return \"1\" /* LoggerTrackingType.TRACKED */;\n}\nfunction computeSessionState(configuration, rawSessionType) {\n    const trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration);\n    return {\n        trackingType,\n        isTracked: trackingType === \"1\" /* LoggerTrackingType.TRACKED */,\n    };\n}\nfunction hasValidLoggerSession(trackingType) {\n    return trackingType === \"0\" /* LoggerTrackingType.NOT_TRACKED */ || trackingType === \"1\" /* LoggerTrackingType.TRACKED */;\n}\n//# sourceMappingURL=logsSessionManager.js.map","import { willSyntheticsInjectRum, addTelemetryDebug, getSyntheticsTestId, getSyntheticsResultId, } from '@datadog/browser-core';\nlet logsSentBeforeRumInjectionTelemetryAdded = false;\nexport function getRUMInternalContext(startTime) {\n    const browserWindow = window;\n    if (willSyntheticsInjectRum()) {\n        const context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS);\n        if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {\n            logsSentBeforeRumInjectionTelemetryAdded = true;\n            addTelemetryDebug('Logs sent before RUM is injected by the synthetics worker', {\n                testId: getSyntheticsTestId(),\n                resultId: getSyntheticsResultId(),\n            });\n        }\n        return context;\n    }\n    return getInternalContextFromRumGlobal(browserWindow.DD_RUM);\n    function getInternalContextFromRumGlobal(rumGlobal) {\n        if (rumGlobal && rumGlobal.getInternalContext) {\n            return rumGlobal.getInternalContext(startTime);\n        }\n    }\n}\nexport function resetRUMInternalContext() {\n    logsSentBeforeRumInjectionTelemetryAdded = false;\n}\n//# sourceMappingURL=rumInternalContext.js.map","import { ErrorSource, combine, createEventRateLimiter, getRelativeTime, isEmptyObject } from '@datadog/browser-core';\nimport { STATUSES } from './logger';\nimport { getRUMInternalContext } from './contexts/rumInternalContext';\nexport function startLogsAssembly(sessionManager, configuration, lifeCycle, getCommonContext, reportError) {\n    const statusWithCustom = STATUSES.concat(['custom']);\n    const logRateLimiters = {};\n    statusWithCustom.forEach((status) => {\n        logRateLimiters[status] = createEventRateLimiter(status, configuration.eventRateLimiterThreshold, reportError);\n    });\n    lifeCycle.subscribe(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, ({ rawLogsEvent, messageContext = undefined, savedCommonContext = undefined, domainContext }) => {\n        var _a, _b;\n        const startTime = getRelativeTime(rawLogsEvent.date);\n        const session = sessionManager.findTrackedSession(startTime);\n        const shouldSendLog = sessionManager.findTrackedSession(startTime, { returnInactive: true });\n        if (!shouldSendLog) {\n            return;\n        }\n        const commonContext = savedCommonContext || getCommonContext();\n        if (session && session.anonymousId && !commonContext.user.anonymous_id) {\n            commonContext.user.anonymous_id = session.anonymousId;\n        }\n        const log = combine({\n            service: configuration.service,\n            session_id: session ? session.id : undefined,\n            session: session ? { id: session.id } : undefined,\n            // Insert user first to allow overrides from global context\n            usr: !isEmptyObject(commonContext.user) ? commonContext.user : undefined,\n            view: commonContext.view,\n        }, commonContext.context, getRUMInternalContext(startTime), rawLogsEvent, messageContext);\n        if (((_a = configuration.beforeSend) === null || _a === void 0 ? void 0 : _a.call(configuration, log, domainContext)) === false ||\n            (log.origin !== ErrorSource.AGENT &&\n                ((_b = logRateLimiters[log.status]) !== null && _b !== void 0 ? _b : logRateLimiters['custom']).isLimitReached())) {\n            return;\n        }\n        lifeCycle.notify(1 /* LifeCycleEventType.LOG_COLLECTED */, log);\n    });\n}\n//# sourceMappingURL=assembly.js.map","import { setTimeout } from '../../tools/timer';\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { ErrorSource } from '../error/error.types';\nexport function createEventRateLimiter(eventType, limit, onLimitReached) {\n    let eventCount = 0;\n    let allowNextEvent = false;\n    return {\n        isLimitReached() {\n            if (eventCount === 0) {\n                setTimeout(() => {\n                    eventCount = 0;\n                }, ONE_MINUTE);\n            }\n            eventCount += 1;\n            if (eventCount <= limit || allowNextEvent) {\n                allowNextEvent = false;\n                return false;\n            }\n            if (eventCount === limit + 1) {\n                allowNextEvent = true;\n                try {\n                    onLimitReached({\n                        message: `Reached max number of ${eventType}s by minute: ${limit}`,\n                        source: ErrorSource.AGENT,\n                        startClocks: clocksNow(),\n                    });\n                }\n                finally {\n                    allowNextEvent = false;\n                }\n            }\n            return true;\n        },\n    };\n}\n//# sourceMappingURL=createEventRateLimiter.js.map","import { flattenErrorCauses, isError, tryToGetFingerprint } from '../error/error';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { ConsoleApiName, globalConsole } from '../../tools/display';\nimport { callMonitored } from '../../tools/monitor';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { ErrorSource } from '../error/error.types';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { createHandlingStack, toStackTraceString, formatErrorMessage } from '../../tools/stackTrace/handlingStack';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nlet consoleObservablesByApi = {};\nexport function initConsoleObservable(apis) {\n    const consoleObservables = apis.map((api) => {\n        if (!consoleObservablesByApi[api]) {\n            consoleObservablesByApi[api] = createConsoleObservable(api); // we are sure that the observable created for this api will yield the expected ConsoleLog type\n        }\n        return consoleObservablesByApi[api];\n    });\n    return mergeObservables(...consoleObservables);\n}\nexport function resetConsoleObservable() {\n    consoleObservablesByApi = {};\n}\nfunction createConsoleObservable(api) {\n    return new Observable((observable) => {\n        const originalConsoleApi = globalConsole[api];\n        globalConsole[api] = (...params) => {\n            originalConsoleApi.apply(console, params);\n            const handlingStack = createHandlingStack();\n            callMonitored(() => {\n                observable.notify(buildConsoleLog(params, api, handlingStack));\n            });\n        };\n        return () => {\n            globalConsole[api] = originalConsoleApi;\n        };\n    });\n}\nfunction buildConsoleLog(params, api, handlingStack) {\n    const message = params.map((param) => formatConsoleParameters(param)).join(' ');\n    let error;\n    if (api === ConsoleApiName.error) {\n        const firstErrorParam = params.find(isError);\n        error = {\n            stack: firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined,\n            fingerprint: tryToGetFingerprint(firstErrorParam),\n            causes: firstErrorParam ? flattenErrorCauses(firstErrorParam, 'console') : undefined,\n            startClocks: clocksNow(),\n            message,\n            source: ErrorSource.CONSOLE,\n            handling: \"handled\" /* ErrorHandling.HANDLED */,\n            handlingStack,\n        };\n    }\n    return {\n        api,\n        message,\n        error,\n        handlingStack,\n    };\n}\nfunction formatConsoleParameters(param) {\n    if (typeof param === 'string') {\n        return sanitize(param);\n    }\n    if (isError(param)) {\n        return formatErrorMessage(computeStackTrace(param));\n    }\n    return jsonStringify(sanitize(param), undefined, 2);\n}\n//# sourceMappingURL=consoleObservable.js.map","import { timeStampNow, ConsoleApiName, ErrorSource, initConsoleObservable } from '@datadog/browser-core';\nimport { StatusType } from '../logger/isAuthorized';\nimport { createErrorFieldFromRawError } from '../createErrorFieldFromRawError';\nexport const LogStatusForApi = {\n    [ConsoleApiName.log]: StatusType.info,\n    [ConsoleApiName.debug]: StatusType.debug,\n    [ConsoleApiName.info]: StatusType.info,\n    [ConsoleApiName.warn]: StatusType.warn,\n    [ConsoleApiName.error]: StatusType.error,\n};\nexport function startConsoleCollection(configuration, lifeCycle) {\n    const consoleSubscription = initConsoleObservable(configuration.forwardConsoleLogs).subscribe((log) => {\n        const collectedData = {\n            rawLogsEvent: {\n                date: timeStampNow(),\n                message: log.message,\n                origin: ErrorSource.CONSOLE,\n                error: log.error && createErrorFieldFromRawError(log.error),\n                status: LogStatusForApi[log.api],\n            },\n            domainContext: {\n                handlingStack: log.handlingStack,\n            },\n        };\n        lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, collectedData);\n    });\n    return {\n        stop: () => {\n            consoleSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=consoleCollection.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nimport { shallowClone } from '../tools/utils/objectUtils';\nimport { addEventListener } from './addEventListener';\nlet xhrObservable;\nconst xhrContexts = new WeakMap();\nexport function initXhrObservable(configuration) {\n    if (!xhrObservable) {\n        xhrObservable = createXhrObservable(configuration);\n    }\n    return xhrObservable;\n}\nfunction createXhrObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop: stopInstrumentingStart } = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr);\n        const { stop: stopInstrumentingSend } = instrumentMethod(XMLHttpRequest.prototype, 'send', (call) => {\n            sendXhr(call, configuration, observable);\n        }, { computeHandlingStack: true });\n        const { stop: stopInstrumentingAbort } = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr);\n        return () => {\n            stopInstrumentingStart();\n            stopInstrumentingSend();\n            stopInstrumentingAbort();\n        };\n    });\n}\nfunction openXhr({ target: xhr, parameters: [method, url] }) {\n    xhrContexts.set(xhr, {\n        state: 'open',\n        method: String(method).toUpperCase(),\n        url: normalizeUrl(String(url)),\n    });\n}\nfunction sendXhr({ target: xhr, handlingStack }, configuration, observable) {\n    const context = xhrContexts.get(xhr);\n    if (!context) {\n        return;\n    }\n    const startContext = context;\n    startContext.state = 'start';\n    startContext.startClocks = clocksNow();\n    startContext.isAborted = false;\n    startContext.xhr = xhr;\n    startContext.handlingStack = handlingStack;\n    let hasBeenReported = false;\n    const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethod(xhr, 'onreadystatechange', () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n            // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n            // application during a future event. For example, Angular is calling .abort() on\n            // completed requests during an onreadystatechange event, so the status becomes '0'\n            // before the request is collected.\n            onEnd();\n        }\n    });\n    const onEnd = () => {\n        unsubscribeLoadEndListener();\n        stopInstrumentingOnReadyStateChange();\n        if (hasBeenReported) {\n            return;\n        }\n        hasBeenReported = true;\n        const completeContext = context;\n        completeContext.state = 'complete';\n        completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n        completeContext.status = xhr.status;\n        observable.notify(shallowClone(completeContext));\n    };\n    const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, xhr, 'loadend', onEnd);\n    observable.notify(startContext);\n}\nfunction abortXhr({ target: xhr }) {\n    const context = xhrContexts.get(xhr);\n    if (context) {\n        context.isAborted = true;\n    }\n}\n//# sourceMappingURL=xhrObservable.js.map","export function isServerError(status) {\n    return status >= 500;\n}\nexport function tryToClone(response) {\n    try {\n        return response.clone();\n    }\n    catch (_a) {\n        // clone can throw if the response has already been used by another instrumentation or is disturbed\n        return;\n    }\n}\n//# sourceMappingURL=responseUtils.js.map","import { ErrorSource, initXhrObservable, initFetchObservable, computeStackTrace, toStackTraceString, monitor, noop, readBytesFromStream, tryToClone, isServerError, isIntakeUrl, } from '@datadog/browser-core';\nimport { StatusType } from '../logger/isAuthorized';\nexport function startNetworkErrorCollection(configuration, lifeCycle) {\n    if (!configuration.forwardErrorsToLogs) {\n        return { stop: noop };\n    }\n    const xhrSubscription = initXhrObservable(configuration).subscribe((context) => {\n        if (context.state === 'complete') {\n            handleResponse(\"xhr\" /* RequestType.XHR */, context);\n        }\n    });\n    const fetchSubscription = initFetchObservable().subscribe((context) => {\n        if (context.state === 'resolve') {\n            handleResponse(\"fetch\" /* RequestType.FETCH */, context);\n        }\n    });\n    function handleResponse(type, request) {\n        if (!isIntakeUrl(request.url) && (isRejected(request) || isServerError(request.status))) {\n            if ('xhr' in request) {\n                computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable);\n            }\n            else if (request.response) {\n                computeFetchResponseText(request.response, configuration, onResponseDataAvailable);\n            }\n            else if (request.error) {\n                computeFetchErrorText(request.error, configuration, onResponseDataAvailable);\n            }\n        }\n        function onResponseDataAvailable(responseData) {\n            const domainContext = {\n                isAborted: request.isAborted,\n                handlingStack: request.handlingStack,\n            };\n            lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {\n                rawLogsEvent: {\n                    message: `${format(type)} error ${request.method} ${request.url}`,\n                    date: request.startClocks.timeStamp,\n                    error: {\n                        stack: responseData || 'Failed to load',\n                        // We don't know if the error was handled or not, so we set it to undefined\n                        handling: undefined,\n                    },\n                    http: {\n                        method: request.method, // Cast resource method because of case mismatch cf issue RUMF-1152\n                        status_code: request.status,\n                        url: request.url,\n                    },\n                    status: StatusType.error,\n                    origin: ErrorSource.NETWORK,\n                },\n                domainContext,\n            });\n        }\n    }\n    return {\n        stop: () => {\n            xhrSubscription.unsubscribe();\n            fetchSubscription.unsubscribe();\n        },\n    };\n}\n// TODO: ideally, computeXhrResponseData should always call the callback with a string instead of\n// `unknown`. But to keep backward compatibility, in the case of XHR with a `responseType` different\n// than \"text\", the response data should be whatever `xhr.response` is. This is a bit confusing as\n// Logs event 'stack' is expected to be a string. This should be changed in a future major version\n// as it could be a breaking change.\nexport function computeXhrResponseData(xhr, configuration, callback) {\n    if (typeof xhr.response === 'string') {\n        callback(truncateResponseText(xhr.response, configuration));\n    }\n    else {\n        callback(xhr.response);\n    }\n}\nexport function computeFetchErrorText(error, configuration, callback) {\n    callback(truncateResponseText(toStackTraceString(computeStackTrace(error)), configuration));\n}\nexport function computeFetchResponseText(response, configuration, callback) {\n    const clonedResponse = tryToClone(response);\n    if (!clonedResponse || !clonedResponse.body) {\n        // if the clone failed or if the body is null, let's not try to read it.\n        callback();\n    }\n    else if (!window.TextDecoder) {\n        // If the browser doesn't support TextDecoder, let's read the whole response then truncate it.\n        //\n        // This should only be the case on early versions of Edge (before they migrated to Chromium).\n        // Even if it could be possible to implement a workaround for the missing TextDecoder API (using\n        // a Blob and FileReader), we found another issue preventing us from reading only the first\n        // bytes from the response: contrary to other browsers, when reading from the cloned response,\n        // if the original response gets canceled, the cloned response is also canceled and we can't\n        // know about it.  In the following illustration, the promise returned by `reader.read()` may\n        // never be fulfilled:\n        //\n        // fetch('/').then((response) => {\n        //   const reader = response.clone().body.getReader()\n        //   readMore()\n        //   function readMore() {\n        //     reader.read().then(\n        //       (result) => {\n        //         if (result.done) {\n        //           console.log('done')\n        //         } else {\n        //           readMore()\n        //         }\n        //       },\n        //       () => console.log('error')\n        //     )\n        //   }\n        //   response.body.getReader().cancel()\n        // })\n        clonedResponse.text().then(monitor((text) => callback(truncateResponseText(text, configuration))), monitor((error) => callback(`Unable to retrieve response: ${error}`)));\n    }\n    else {\n        truncateResponseStream(clonedResponse.body, configuration.requestErrorResponseLengthLimit, (error, responseText) => {\n            if (error) {\n                callback(`Unable to retrieve response: ${error}`);\n            }\n            else {\n                callback(responseText);\n            }\n        });\n    }\n}\nfunction isRejected(request) {\n    return request.status === 0 && request.responseType !== 'opaque';\n}\nfunction truncateResponseText(responseText, configuration) {\n    if (responseText.length > configuration.requestErrorResponseLengthLimit) {\n        return `${responseText.substring(0, configuration.requestErrorResponseLengthLimit)}...`;\n    }\n    return responseText;\n}\nfunction format(type) {\n    if (\"xhr\" /* RequestType.XHR */ === type) {\n        return 'XHR';\n    }\n    return 'Fetch';\n}\nfunction truncateResponseStream(stream, bytesLimit, callback) {\n    readBytesFromStream(stream, (error, bytes, limitExceeded) => {\n        if (error) {\n            callback(error);\n        }\n        else {\n            let responseText = new TextDecoder().decode(bytes);\n            if (limitExceeded) {\n                responseText += '...';\n            }\n            callback(undefined, responseText);\n        }\n    }, {\n        bytesLimit,\n        collectStreamBody: true,\n    });\n}\n//# sourceMappingURL=networkErrorCollection.js.map","import { monitor } from './monitor';\nimport { noop } from './utils/functionUtils';\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(stream, callback, options) {\n    const reader = stream.getReader();\n    const chunks = [];\n    let readBytesCount = 0;\n    readMore();\n    function readMore() {\n        reader.read().then(monitor((result) => {\n            if (result.done) {\n                onDone();\n                return;\n            }\n            if (options.collectStreamBody) {\n                chunks.push(result.value);\n            }\n            readBytesCount += result.value.length;\n            if (readBytesCount > options.bytesLimit) {\n                onDone();\n            }\n            else {\n                readMore();\n            }\n        }), monitor((error) => callback(error)));\n    }\n    function onDone() {\n        reader.cancel().catch(\n        // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n        // as an unhandled rejection\n        noop);\n        let bytes;\n        let limitExceeded;\n        if (options.collectStreamBody) {\n            let completeBuffer;\n            if (chunks.length === 1) {\n                // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n                // use it directly.\n                completeBuffer = chunks[0];\n            }\n            else {\n                // else, we need to copy buffers into a larger buffer to concatenate them.\n                completeBuffer = new Uint8Array(readBytesCount);\n                let offset = 0;\n                chunks.forEach((chunk) => {\n                    completeBuffer.set(chunk, offset);\n                    offset += chunk.length;\n                });\n            }\n            bytes = completeBuffer.slice(0, options.bytesLimit);\n            limitExceeded = completeBuffer.length > options.bytesLimit;\n        }\n        callback(undefined, bytes, limitExceeded);\n    }\n}\n//# sourceMappingURL=readBytesFromStream.js.map","import { instrumentMethod } from '../../tools/instrumentMethod';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nimport { computeStackTrace, computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace';\nimport { computeRawError, isError } from './error';\nimport { ErrorSource } from './error.types';\nexport function trackRuntimeError(errorObservable) {\n    const handleRuntimeError = (stackTrace, originalError) => {\n        const rawError = computeRawError({\n            stackTrace,\n            originalError,\n            startClocks: clocksNow(),\n            nonErrorPrefix: \"Uncaught\" /* NonErrorPrefix.UNCAUGHT */,\n            source: ErrorSource.SOURCE,\n            handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n        });\n        errorObservable.notify(rawError);\n    };\n    const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError);\n    const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError);\n    return {\n        stop: () => {\n            stopInstrumentingOnError();\n            stopInstrumentingOnUnhandledRejection();\n        },\n    };\n}\nexport function instrumentOnError(callback) {\n    return instrumentMethod(window, 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {\n        let stackTrace;\n        if (isError(errorObj)) {\n            stackTrace = computeStackTrace(errorObj);\n        }\n        else {\n            stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column);\n        }\n        callback(stackTrace, errorObj !== null && errorObj !== void 0 ? errorObj : messageObj);\n    });\n}\nexport function instrumentUnhandledRejection(callback) {\n    return instrumentMethod(window, 'onunhandledrejection', ({ parameters: [e] }) => {\n        const reason = e.reason || 'Empty reason';\n        const stack = computeStackTrace(reason);\n        callback(stack, reason);\n    });\n}\n//# sourceMappingURL=trackRuntimeError.js.map","import { AbstractLifeCycle } from '@datadog/browser-core';\nexport const LifeCycle = (AbstractLifeCycle);\n//# sourceMappingURL=lifeCycle.js.map","// eslint-disable-next-line no-restricted-syntax\nexport class AbstractLifeCycle {\n    constructor() {\n        this.callbacks = {};\n    }\n    notify(eventType, data) {\n        const eventCallbacks = this.callbacks[eventType];\n        if (eventCallbacks) {\n            eventCallbacks.forEach((callback) => callback(data));\n        }\n    }\n    subscribe(eventType, callback) {\n        if (!this.callbacks[eventType]) {\n            this.callbacks[eventType] = [];\n        }\n        this.callbacks[eventType].push(callback);\n        return {\n            unsubscribe: () => {\n                this.callbacks[eventType] = this.callbacks[eventType].filter((other) => callback !== other);\n            },\n        };\n    }\n}\n//# sourceMappingURL=abstractLifeCycle.js.map","import { combine, ErrorSource, timeStampNow, originalConsoleMethods, globalConsole, ConsoleApiName, } from '@datadog/browser-core';\nimport { HandlerType } from '../logger';\nimport { isAuthorized, StatusType } from './isAuthorized';\nexport function startLoggerCollection(lifeCycle) {\n    function handleLog(logsMessage, logger, handlingStack, savedCommonContext, savedDate) {\n        const messageContext = combine(logger.getContext(), logsMessage.context);\n        if (isAuthorized(logsMessage.status, HandlerType.console, logger)) {\n            displayInConsole(logsMessage, messageContext);\n        }\n        if (isAuthorized(logsMessage.status, HandlerType.http, logger)) {\n            const rawLogEventData = {\n                rawLogsEvent: {\n                    date: savedDate || timeStampNow(),\n                    message: logsMessage.message,\n                    status: logsMessage.status,\n                    origin: ErrorSource.LOGGER,\n                },\n                messageContext,\n                savedCommonContext,\n            };\n            if (handlingStack) {\n                rawLogEventData.domainContext = { handlingStack };\n            }\n            lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, rawLogEventData);\n        }\n    }\n    return {\n        handleLog,\n    };\n}\nconst loggerToConsoleApiName = {\n    [StatusType.ok]: ConsoleApiName.debug,\n    [StatusType.debug]: ConsoleApiName.debug,\n    [StatusType.info]: ConsoleApiName.info,\n    [StatusType.notice]: ConsoleApiName.info,\n    [StatusType.warn]: ConsoleApiName.warn,\n    [StatusType.error]: ConsoleApiName.error,\n    [StatusType.critical]: ConsoleApiName.error,\n    [StatusType.alert]: ConsoleApiName.error,\n    [StatusType.emerg]: ConsoleApiName.error,\n};\nfunction displayInConsole({ status, message }, messageContext) {\n    originalConsoleMethods[loggerToConsoleApiName[status]].call(globalConsole, message, messageContext);\n}\n//# sourceMappingURL=loggerCollection.js.map","import { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../tools/display';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { isPageExitReason } from '../browser/pageExitObservable';\nimport { jsonStringify } from '../tools/serialisation/jsonStringify';\nimport { computeBytesCount } from '../tools/utils/byteUtils';\nexport function createBatch({ encoder, request, flushController, messageBytesLimit, }) {\n    let upsertBuffer = {};\n    const flushSubscription = flushController.flushObservable.subscribe((event) => flush(event));\n    function push(serializedMessage, estimatedMessageBytesCount, key) {\n        flushController.notifyBeforeAddMessage(estimatedMessageBytesCount);\n        if (key !== undefined) {\n            upsertBuffer[key] = serializedMessage;\n            flushController.notifyAfterAddMessage();\n        }\n        else {\n            encoder.write(encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`, (realMessageBytesCount) => {\n                flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount);\n            });\n        }\n    }\n    function hasMessageFor(key) {\n        return key !== undefined && upsertBuffer[key] !== undefined;\n    }\n    function remove(key) {\n        const removedMessage = upsertBuffer[key];\n        delete upsertBuffer[key];\n        const messageBytesCount = encoder.estimateEncodedBytesCount(removedMessage);\n        flushController.notifyAfterRemoveMessage(messageBytesCount);\n    }\n    function addOrUpdate(message, key) {\n        const serializedMessage = jsonStringify(message);\n        const estimatedMessageBytesCount = encoder.estimateEncodedBytesCount(serializedMessage);\n        if (estimatedMessageBytesCount >= messageBytesLimit) {\n            display.warn(`Discarded a message whose size was bigger than the maximum allowed size ${messageBytesLimit}KB. ${MORE_DETAILS} ${DOCS_TROUBLESHOOTING}/#technical-limitations`);\n            return;\n        }\n        if (hasMessageFor(key)) {\n            remove(key);\n        }\n        push(serializedMessage, estimatedMessageBytesCount, key);\n    }\n    function flush(event) {\n        const upsertMessages = objectValues(upsertBuffer).join('\\n');\n        upsertBuffer = {};\n        const isPageExit = isPageExitReason(event.reason);\n        const send = isPageExit ? request.sendOnExit : request.send;\n        if (isPageExit &&\n            // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n            // if the encoder is async we need to send two requests in some cases (one for encoded data\n            // and the other for non-encoded data). But if it's not async, we don't have to worry about\n            // it and always send a single request.\n            encoder.isAsync) {\n            const encoderResult = encoder.finishSync();\n            // Send encoded messages\n            if (encoderResult.outputBytesCount) {\n                send(formatPayloadFromEncoder(encoderResult));\n            }\n            // Send messages that are not yet encoded at this point\n            const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n');\n            if (pendingMessages) {\n                send({\n                    data: pendingMessages,\n                    bytesCount: computeBytesCount(pendingMessages),\n                });\n            }\n        }\n        else {\n            if (upsertMessages) {\n                encoder.write(encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`);\n            }\n            encoder.finish((encoderResult) => {\n                send(formatPayloadFromEncoder(encoderResult));\n            });\n        }\n    }\n    return {\n        flushController,\n        add: addOrUpdate,\n        upsert: addOrUpdate,\n        stop: flushSubscription.unsubscribe,\n    };\n}\nfunction formatPayloadFromEncoder(encoderResult) {\n    let data;\n    if (typeof encoderResult.output === 'string') {\n        data = encoderResult.output;\n    }\n    else {\n        data = new Blob([encoderResult.output], {\n            // This will set the 'Content-Type: text/plain' header. Reasoning:\n            // * The intake rejects the request if there is no content type.\n            // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n            // could induce higher intake load (and maybe has other impacts).\n            // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n            // new lines.\n            type: 'text/plain',\n        });\n    }\n    return {\n        data,\n        bytesCount: encoderResult.outputBytesCount,\n        encoding: encoderResult.encoding,\n    };\n}\n//# sourceMappingURL=batch.js.map","import { setTimeout } from '../tools/timer';\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nimport { isServerError } from '../tools/utils/responseUtils';\nimport { ErrorSource } from '../domain/error/error.types';\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;\nexport const MAX_ONGOING_REQUESTS = 32;\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;\nexport const MAX_BACKOFF_TIME = ONE_MINUTE;\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND;\nexport function sendWithRetryStrategy(payload, state, sendStrategy, trackType, reportError) {\n    if (state.transportStatus === 0 /* TransportStatus.UP */ &&\n        state.queuedPayloads.size() === 0 &&\n        state.bandwidthMonitor.canHandle(payload)) {\n        send(payload, state, sendStrategy, {\n            onSuccess: () => retryQueuedPayloads(0 /* RetryReason.AFTER_SUCCESS */, state, sendStrategy, trackType, reportError),\n            onFailure: () => {\n                state.queuedPayloads.enqueue(payload);\n                scheduleRetry(state, sendStrategy, trackType, reportError);\n            },\n        });\n    }\n    else {\n        state.queuedPayloads.enqueue(payload);\n    }\n}\nfunction scheduleRetry(state, sendStrategy, trackType, reportError) {\n    if (state.transportStatus !== 2 /* TransportStatus.DOWN */) {\n        return;\n    }\n    setTimeout(() => {\n        const payload = state.queuedPayloads.first();\n        send(payload, state, sendStrategy, {\n            onSuccess: () => {\n                state.queuedPayloads.dequeue();\n                state.currentBackoffTime = INITIAL_BACKOFF_TIME;\n                retryQueuedPayloads(1 /* RetryReason.AFTER_RESUME */, state, sendStrategy, trackType, reportError);\n            },\n            onFailure: () => {\n                state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);\n                scheduleRetry(state, sendStrategy, trackType, reportError);\n            },\n        });\n    }, state.currentBackoffTime);\n}\nfunction send(payload, state, sendStrategy, { onSuccess, onFailure }) {\n    state.bandwidthMonitor.add(payload);\n    sendStrategy(payload, (response) => {\n        state.bandwidthMonitor.remove(payload);\n        if (!shouldRetryRequest(response)) {\n            state.transportStatus = 0 /* TransportStatus.UP */;\n            onSuccess();\n        }\n        else {\n            // do not consider transport down if another ongoing request could succeed\n            state.transportStatus =\n                state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* TransportStatus.FAILURE_DETECTED */ : 2 /* TransportStatus.DOWN */;\n            payload.retry = {\n                count: payload.retry ? payload.retry.count + 1 : 1,\n                lastFailureStatus: response.status,\n            };\n            onFailure();\n        }\n    });\n}\nfunction retryQueuedPayloads(reason, state, sendStrategy, trackType, reportError) {\n    if (reason === 0 /* RetryReason.AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {\n        reportError({\n            message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n        });\n        state.queueFullReported = true;\n    }\n    const previousQueue = state.queuedPayloads;\n    state.queuedPayloads = newPayloadQueue();\n    while (previousQueue.size() > 0) {\n        sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, trackType, reportError);\n    }\n}\nfunction shouldRetryRequest(response) {\n    return (response.type !== 'opaque' &&\n        ((response.status === 0 && !navigator.onLine) ||\n            response.status === 408 ||\n            response.status === 429 ||\n            isServerError(response.status)));\n}\nexport function newRetryState() {\n    return {\n        transportStatus: 0 /* TransportStatus.UP */,\n        currentBackoffTime: INITIAL_BACKOFF_TIME,\n        bandwidthMonitor: newBandwidthMonitor(),\n        queuedPayloads: newPayloadQueue(),\n        queueFullReported: false,\n    };\n}\nfunction newPayloadQueue() {\n    const queue = [];\n    return {\n        bytesCount: 0,\n        enqueue(payload) {\n            if (this.isFull()) {\n                return;\n            }\n            queue.push(payload);\n            this.bytesCount += payload.bytesCount;\n        },\n        first() {\n            return queue[0];\n        },\n        dequeue() {\n            const payload = queue.shift();\n            if (payload) {\n                this.bytesCount -= payload.bytesCount;\n            }\n            return payload;\n        },\n        size() {\n            return queue.length;\n        },\n        isFull() {\n            return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;\n        },\n    };\n}\nfunction newBandwidthMonitor() {\n    return {\n        ongoingRequestCount: 0,\n        ongoingByteCount: 0,\n        canHandle(payload) {\n            return (this.ongoingRequestCount === 0 ||\n                (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n                    this.ongoingRequestCount < MAX_ONGOING_REQUESTS));\n        },\n        add(payload) {\n            this.ongoingRequestCount += 1;\n            this.ongoingByteCount += payload.bytesCount;\n        },\n        remove(payload) {\n            this.ongoingRequestCount -= 1;\n            this.ongoingByteCount -= payload.bytesCount;\n        },\n    };\n}\n//# sourceMappingURL=sendWithRetryStrategy.js.map","import { addTelemetryError } from '../domain/telemetry';\nimport { monitor } from '../tools/monitor';\nimport { addEventListener } from '../browser/addEventListener';\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy';\nexport function createHttpRequest(endpointBuilder, bytesLimit, reportError) {\n    const retryState = newRetryState();\n    const sendStrategyForRetry = (payload, onResponse) => fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);\n    return {\n        send: (payload) => {\n            sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError);\n        },\n        /**\n         * Since fetch keepalive behaves like regular fetch on Firefox,\n         * keep using sendBeaconStrategy on exit\n         */\n        sendOnExit: (payload) => {\n            sendBeaconStrategy(endpointBuilder, bytesLimit, payload);\n        },\n    };\n}\nfunction sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {\n    const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;\n    if (canUseBeacon) {\n        try {\n            const beaconUrl = endpointBuilder.build('beacon', payload);\n            const isQueued = navigator.sendBeacon(beaconUrl, payload.data);\n            if (isQueued) {\n                return;\n            }\n        }\n        catch (e) {\n            reportBeaconError(e);\n        }\n    }\n    const xhrUrl = endpointBuilder.build('xhr', payload);\n    sendXHR(xhrUrl, payload.data);\n}\nlet hasReportedBeaconError = false;\nfunction reportBeaconError(e) {\n    if (!hasReportedBeaconError) {\n        hasReportedBeaconError = true;\n        addTelemetryError(e);\n    }\n}\nexport function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {\n    const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;\n    if (canUseKeepAlive) {\n        const fetchUrl = endpointBuilder.build('fetch', payload);\n        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' }).then(monitor((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })), monitor(() => {\n            const xhrUrl = endpointBuilder.build('xhr', payload);\n            // failed to queue the request\n            sendXHR(xhrUrl, payload.data, onResponse);\n        }));\n    }\n    else {\n        const xhrUrl = endpointBuilder.build('xhr', payload);\n        sendXHR(xhrUrl, payload.data, onResponse);\n    }\n}\nfunction isKeepAliveSupported() {\n    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n    try {\n        return window.Request && 'keepalive' in new Request('http://a');\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function sendXHR(url, data, onResponse) {\n    const request = new XMLHttpRequest();\n    request.open('POST', url, true);\n    if (data instanceof Blob) {\n        // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n        // automatically, so the intake request ends up being rejected with an HTTP status 415\n        // Defining the header manually fixes this issue.\n        request.setRequestHeader('Content-Type', data.type);\n    }\n    addEventListener(\n    // allow untrusted event to acount for synthetic event dispatched by third party xhr wrapper\n    { allowUntrustedEvents: true }, request, 'loadend', () => {\n        onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: request.status });\n    }, {\n        // prevent multiple onResponse callbacks\n        // if the xhr instance is reused by a third party\n        once: true,\n    });\n    request.send(data);\n}\n//# sourceMappingURL=httpRequest.js.map","import { Observable } from '../tools/observable';\nimport { clearTimeout, setTimeout } from '../tools/timer';\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({ messagesLimit, bytesLimit, durationLimit, pageExitObservable, sessionExpireObservable, }) {\n    const pageExitSubscription = pageExitObservable.subscribe((event) => flush(event.reason));\n    const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'));\n    const flushObservable = new Observable(() => () => {\n        pageExitSubscription.unsubscribe();\n        sessionExpireSubscription.unsubscribe();\n    });\n    let currentBytesCount = 0;\n    let currentMessagesCount = 0;\n    function flush(flushReason) {\n        if (currentMessagesCount === 0) {\n            return;\n        }\n        const messagesCount = currentMessagesCount;\n        const bytesCount = currentBytesCount;\n        currentMessagesCount = 0;\n        currentBytesCount = 0;\n        cancelDurationLimitTimeout();\n        flushObservable.notify({\n            reason: flushReason,\n            messagesCount,\n            bytesCount,\n        });\n    }\n    let durationLimitTimeoutId;\n    function scheduleDurationLimitTimeout() {\n        if (durationLimitTimeoutId === undefined) {\n            durationLimitTimeoutId = setTimeout(() => {\n                flush('duration_limit');\n            }, durationLimit);\n        }\n    }\n    function cancelDurationLimitTimeout() {\n        clearTimeout(durationLimitTimeoutId);\n        durationLimitTimeoutId = undefined;\n    }\n    return {\n        flushObservable,\n        get messagesCount() {\n            return currentMessagesCount;\n        },\n        /**\n         * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right before adding the message, so no flush\n         * event can happen after `notifyBeforeAddMessage` and before adding the message.\n         *\n         * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n         * actually added.\n         */\n        notifyBeforeAddMessage(estimatedMessageBytesCount) {\n            if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n                flush('bytes_limit');\n            }\n            // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n            // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n            // to notify when a flush is needed (for example on page exit).\n            currentMessagesCount += 1;\n            currentBytesCount += estimatedMessageBytesCount;\n            scheduleDurationLimitTimeout();\n        },\n        /**\n         * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n         *\n         * This function can be called asynchronously after the message was added, but in this case it\n         * should not be called if a flush event occurred in between.\n         *\n         * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n         * its actual bytes count once added to the pool.\n         */\n        notifyAfterAddMessage(messageBytesCountDiff = 0) {\n            currentBytesCount += messageBytesCountDiff;\n            if (currentMessagesCount >= messagesLimit) {\n                flush('messages_limit');\n            }\n            else if (currentBytesCount >= bytesLimit) {\n                flush('bytes_limit');\n            }\n        },\n        /**\n         * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right after removing the message, so no flush\n         * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n         *\n         * @param messageBytesCount: the message bytes count that was added to the pool. Should\n         * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n         * `notifyAfterAddMessage`.\n         */\n        notifyAfterRemoveMessage(messageBytesCount) {\n            currentBytesCount -= messageBytesCount;\n            currentMessagesCount -= 1;\n            if (currentMessagesCount === 0) {\n                cancelDurationLimitTimeout();\n            }\n        },\n    };\n}\n//# sourceMappingURL=flushController.js.map","import { createBatch } from './batch';\nimport { createHttpRequest } from './httpRequest';\nimport { createFlushController } from './flushController';\nexport function startBatchWithReplica(configuration, primary, replica, reportError, pageExitObservable, sessionExpireObservable, batchFactoryImp = createBatch) {\n    const primaryBatch = createBatchFromConfig(configuration, primary);\n    const replicaBatch = replica && createBatchFromConfig(configuration, replica);\n    function createBatchFromConfig(configuration, { endpoint, encoder }) {\n        return batchFactoryImp({\n            encoder,\n            request: createHttpRequest(endpoint, configuration.batchBytesLimit, reportError),\n            flushController: createFlushController({\n                messagesLimit: configuration.batchMessagesLimit,\n                bytesLimit: configuration.batchBytesLimit,\n                durationLimit: configuration.flushTimeout,\n                pageExitObservable,\n                sessionExpireObservable,\n            }),\n            messageBytesLimit: configuration.messageBytesLimit,\n        });\n    }\n    return {\n        flushObservable: primaryBatch.flushController.flushObservable,\n        add(message, replicated = true) {\n            primaryBatch.add(message);\n            if (replicaBatch && replicated) {\n                replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message);\n            }\n        },\n        upsert: (message, key) => {\n            primaryBatch.upsert(message, key);\n            if (replicaBatch) {\n                replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key);\n            }\n        },\n        stop: () => {\n            primaryBatch.stop();\n            if (replicaBatch) {\n                replicaBatch.stop();\n            }\n        },\n    };\n}\n//# sourceMappingURL=startBatchWithReplica.js.map","import { computeBytesCount } from './utils/byteUtils';\nexport function createIdentityEncoder() {\n    let output = '';\n    let outputBytesCount = 0;\n    return {\n        isAsync: false,\n        get isEmpty() {\n            return !output;\n        },\n        write(data, callback) {\n            const additionalEncodedBytesCount = computeBytesCount(data);\n            outputBytesCount += additionalEncodedBytesCount;\n            output += data;\n            if (callback) {\n                callback(additionalEncodedBytesCount);\n            }\n        },\n        finish(callback) {\n            callback(this.finishSync());\n        },\n        finishSync() {\n            const result = {\n                output,\n                outputBytesCount,\n                rawBytesCount: outputBytesCount,\n                pendingData: '',\n            };\n            output = '';\n            outputBytesCount = 0;\n            return result;\n        },\n        estimateEncodedBytesCount(data) {\n            return data.length;\n        },\n    };\n}\n//# sourceMappingURL=encoder.js.map","import { startTelemetry, canUseEventBridge, getEventBridge, startBatchWithReplica, createIdentityEncoder, isTelemetryReplicationAllowed, addTelemetryConfiguration, drainPreStartTelemetry, } from '@datadog/browser-core';\nimport { getRUMInternalContext } from './contexts/rumInternalContext';\nimport { serializeLogsConfiguration } from './configuration';\nexport function startLogsTelemetry(initConfiguration, configuration, reportError, pageExitObservable, session) {\n    const telemetry = startTelemetry(\"browser-logs-sdk\" /* TelemetryService.LOGS */, configuration);\n    telemetry.setContextProvider(() => {\n        var _a, _b, _c, _d, _e, _f;\n        return ({\n            application: {\n                id: (_a = getRUMInternalContext()) === null || _a === void 0 ? void 0 : _a.application_id,\n            },\n            session: {\n                id: (_b = session.findTrackedSession()) === null || _b === void 0 ? void 0 : _b.id,\n            },\n            view: {\n                id: (_d = (_c = getRUMInternalContext()) === null || _c === void 0 ? void 0 : _c.view) === null || _d === void 0 ? void 0 : _d.id,\n            },\n            action: {\n                id: (_f = (_e = getRUMInternalContext()) === null || _e === void 0 ? void 0 : _e.user_action) === null || _f === void 0 ? void 0 : _f.id,\n            },\n        });\n    });\n    const cleanupTasks = [];\n    if (canUseEventBridge()) {\n        const bridge = getEventBridge();\n        const telemetrySubscription = telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event));\n        cleanupTasks.push(() => telemetrySubscription.unsubscribe());\n    }\n    else {\n        const telemetryBatch = startBatchWithReplica(configuration, {\n            endpoint: configuration.rumEndpointBuilder,\n            encoder: createIdentityEncoder(),\n        }, configuration.replica && {\n            endpoint: configuration.replica.rumEndpointBuilder,\n            encoder: createIdentityEncoder(),\n        }, reportError, pageExitObservable, session.expireObservable);\n        cleanupTasks.push(() => telemetryBatch.stop());\n        const telemetrySubscription = telemetry.observable.subscribe((event) => telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration)));\n        cleanupTasks.push(() => telemetrySubscription.unsubscribe());\n    }\n    drainPreStartTelemetry();\n    addTelemetryConfiguration(serializeLogsConfiguration(initConfiguration));\n    return {\n        telemetry,\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\n//# sourceMappingURL=logsTelemetry.js.map","import { defineGlobal, getGlobalObject } from '@datadog/browser-core';\nimport { makeLogsPublicApi } from '../boot/logsPublicApi';\nimport { startLogs } from '../boot/startLogs';\nexport { Logger, HandlerType } from '../domain/logger';\nexport { StatusType } from '../domain/logger/isAuthorized';\nexport const datadogLogs = makeLogsPublicApi(startLogs);\ndefineGlobal(getGlobalObject(), 'DD_LOGS', datadogLogs);\n//# sourceMappingURL=main.js.map","export function buildCommonContext(globalContextManager, userContextManager) {\n    return {\n        view: {\n            referrer: document.referrer,\n            url: window.location.href,\n        },\n        context: globalContextManager.getContext(),\n        user: userContextManager.getContext(),\n    };\n}\n//# sourceMappingURL=commonContext.js.map","import { sendToExtension, createPageExitObservable, willSyntheticsInjectRum, canUseEventBridge, } from '@datadog/browser-core';\nimport { startLogsSessionManager, startLogsSessionManagerStub } from '../domain/logsSessionManager';\nimport { startLogsAssembly } from '../domain/assembly';\nimport { startConsoleCollection } from '../domain/console/consoleCollection';\nimport { startReportCollection } from '../domain/report/reportCollection';\nimport { startNetworkErrorCollection } from '../domain/networkError/networkErrorCollection';\nimport { startRuntimeErrorCollection } from '../domain/runtimeError/runtimeErrorCollection';\nimport { LifeCycle } from '../domain/lifeCycle';\nimport { startLoggerCollection } from '../domain/logger/loggerCollection';\nimport { startLogsBatch } from '../transport/startLogsBatch';\nimport { startLogsBridge } from '../transport/startLogsBridge';\nimport { startInternalContext } from '../domain/contexts/internalContext';\nimport { startReportError } from '../domain/reportError';\nimport { startLogsTelemetry } from '../domain/logsTelemetry';\nexport function startLogs(initConfiguration, configuration, getCommonContext, \n// `startLogs` and its subcomponents assume tracking consent is granted initially and starts\n// collecting logs unconditionally. As such, `startLogs` should be called with a\n// `trackingConsentState` set to \"granted\".\ntrackingConsentState) {\n    const lifeCycle = new LifeCycle();\n    const cleanupTasks = [];\n    lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, (log) => sendToExtension('logs', log));\n    const reportError = startReportError(lifeCycle);\n    const pageExitObservable = createPageExitObservable(configuration);\n    const session = configuration.sessionStoreStrategyType && !canUseEventBridge() && !willSyntheticsInjectRum()\n        ? startLogsSessionManager(configuration, trackingConsentState)\n        : startLogsSessionManagerStub(configuration);\n    const { stop: stopLogsTelemetry } = startLogsTelemetry(initConfiguration, configuration, reportError, pageExitObservable, session);\n    cleanupTasks.push(() => stopLogsTelemetry());\n    startNetworkErrorCollection(configuration, lifeCycle);\n    startRuntimeErrorCollection(configuration, lifeCycle);\n    startConsoleCollection(configuration, lifeCycle);\n    startReportCollection(configuration, lifeCycle);\n    const { handleLog } = startLoggerCollection(lifeCycle);\n    startLogsAssembly(session, configuration, lifeCycle, getCommonContext, reportError);\n    if (!canUseEventBridge()) {\n        const { stop: stopLogsBatch } = startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable, session);\n        cleanupTasks.push(() => stopLogsBatch());\n    }\n    else {\n        startLogsBridge(lifeCycle);\n    }\n    const internalContext = startInternalContext(session);\n    return {\n        handleLog,\n        getInternalContext: internalContext.get,\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\n//# sourceMappingURL=startLogs.js.map","import { ErrorSource, addTelemetryDebug } from '@datadog/browser-core';\nimport { StatusType } from './logger/isAuthorized';\nexport function startReportError(lifeCycle) {\n    return (error) => {\n        lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {\n            rawLogsEvent: {\n                message: error.message,\n                date: error.startClocks.timeStamp,\n                origin: ErrorSource.AGENT,\n                status: StatusType.error,\n            },\n        });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n}\n//# sourceMappingURL=reportError.js.map","import { noop, ErrorSource, trackRuntimeError, Observable } from '@datadog/browser-core';\nimport { StatusType } from '../logger/isAuthorized';\nimport { createErrorFieldFromRawError } from '../createErrorFieldFromRawError';\nexport function startRuntimeErrorCollection(configuration, lifeCycle) {\n    if (!configuration.forwardErrorsToLogs) {\n        return { stop: noop };\n    }\n    const rawErrorObservable = new Observable();\n    const { stop: stopRuntimeErrorTracking } = trackRuntimeError(rawErrorObservable);\n    const rawErrorSubscription = rawErrorObservable.subscribe((rawError) => {\n        lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {\n            rawLogsEvent: {\n                message: rawError.message,\n                date: rawError.startClocks.timeStamp,\n                error: createErrorFieldFromRawError(rawError),\n                origin: ErrorSource.SOURCE,\n                status: StatusType.error,\n            },\n        });\n    });\n    return {\n        stop: () => {\n            stopRuntimeErrorTracking();\n            rawErrorSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=runtimeErrorCollection.js.map","import { timeStampNow, ErrorSource, getFileFromStackTraceString, initReportObservable } from '@datadog/browser-core';\nimport { StatusType } from '../logger/isAuthorized';\nimport { createErrorFieldFromRawError } from '../createErrorFieldFromRawError';\nexport function startReportCollection(configuration, lifeCycle) {\n    const reportSubscription = initReportObservable(configuration, configuration.forwardReports).subscribe((rawError) => {\n        let message = rawError.message;\n        let error;\n        const status = rawError.originalError.type === 'deprecation' ? StatusType.warn : StatusType.error;\n        if (status === StatusType.error) {\n            error = createErrorFieldFromRawError(rawError);\n        }\n        else if (rawError.stack) {\n            message += ` Found in ${getFileFromStackTraceString(rawError.stack)}`;\n        }\n        lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {\n            rawLogsEvent: {\n                date: timeStampNow(),\n                message,\n                origin: ErrorSource.REPORT,\n                error,\n                status,\n            },\n        });\n    });\n    return {\n        stop: () => {\n            reportSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=reportCollection.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startLogsBridge(lifeCycle) {\n    const bridge = getEventBridge();\n    lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, (serverLogsEvent) => {\n        bridge.send('log', serverLogsEvent);\n    });\n}\n//# sourceMappingURL=startLogsBridge.js.map","import { createIdentityEncoder, startBatchWithReplica } from '@datadog/browser-core';\nexport function startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable, session) {\n    const batch = startBatchWithReplica(configuration, {\n        endpoint: configuration.logsEndpointBuilder,\n        encoder: createIdentityEncoder(),\n    }, configuration.replica && {\n        endpoint: configuration.replica.logsEndpointBuilder,\n        encoder: createIdentityEncoder(),\n    }, reportError, pageExitObservable, session.expireObservable);\n    lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, (serverLogsEvent) => {\n        batch.add(serverLogsEvent);\n    });\n    return batch;\n}\n//# sourceMappingURL=startLogsBatch.js.map","export function startInternalContext(sessionManager) {\n    return {\n        get: (startTime) => {\n            const trackedSession = sessionManager.findTrackedSession(startTime);\n            if (trackedSession) {\n                return {\n                    session_id: trackedSession.id,\n                };\n            }\n        },\n    };\n}\n//# sourceMappingURL=internalContext.js.map","import { catchUserErrors } from '../tools/catchUserErrors';\nimport { setDebugMode } from '../tools/monitor';\nimport { display } from '../tools/display';\nexport function makePublicApi(stub) {\n    const publicApi = {\n        version: \"6.0.0\",\n        // This API method is intentionally not monitored, since the only thing executed is the\n        // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n        // we don't want to interfere with the user uncaught exceptions.\n        onReady(callback) {\n            callback();\n        },\n        ...stub,\n    };\n    // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n    // as much as possible but of course it's not a real protection.\n    Object.defineProperty(publicApi, '_setDebug', {\n        get() {\n            return setDebugMode;\n        },\n        enumerable: false,\n    });\n    return publicApi;\n}\nexport function defineGlobal(global, name, api) {\n    const existingGlobalVariable = global[name];\n    if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n        display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.');\n    }\n    global[name] = api;\n    if (existingGlobalVariable && existingGlobalVariable.q) {\n        existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')());\n    }\n}\n//# sourceMappingURL=init.js.map","import { config } from '../config/config'\r\n\r\nasync function request<T>(url: string, options?: RequestInit): Promise<T> {\r\n  const response = await fetch(url, options)\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`API request failed: ${response.status} ${response.statusText}`)\r\n  }\r\n\r\n  return response.json() as Promise<T>\r\n}\r\n\r\nexport class ApiClient {\r\n  private baseUrl: string\r\n  constructor(baseUrl: string) {\r\n    this.baseUrl = baseUrl\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    const url = `${this.baseUrl}/health/ping`\r\n    const response = await fetch(url)\r\n    if (response.ok && (await response.text()) === 'pong') return true\r\n    return false\r\n  }\r\n\r\n  async getDebugConfig(): Promise<DebugEntity> {\r\n    return request<DebugEntity>(`${this.baseUrl}/api/v1/debug/config`)\r\n  }\r\n\r\n  async postDebugBundle(data: string | Promise<string>): Promise<string> {\r\n    const url = `${this.baseUrl}/api/v1/debug/bundle`\r\n    const body = isPromise(data) ? await data : (data as string)\r\n    const options = {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'text/plain',\r\n      },\r\n      body: body,\r\n    }\r\n\r\n    const response = await fetch(url, options)\r\n    if (!response.ok) {\r\n      throw new Error(`API request failed: ${response.status} ${response.statusText}`)\r\n    }\r\n    return response.text()\r\n  }\r\n}\r\n\r\nfunction isPromise(data: any): boolean {\r\n  return typeof data.then === 'function'\r\n}\r\n\r\nexport const apiClient = new ApiClient(config.apiUrl)\r\nexport interface DebugEntity {\r\n  excludeErrorPattern: string[]\r\n  saveBundleErrorPattern: string[]\r\n}\r\n","export interface IConfig {\r\n  env: Env\r\n  version: string\r\n  apiUrl: string\r\n}\r\n\r\nexport const config: IConfig = {\r\n  env: ENV,\r\n  version: VERSION,\r\n  apiUrl: API_URL,\r\n}\r\n","const prefix = 'canvas-quiz-loader'\r\n\r\nexport interface BrowserMessage {\r\n  type: BrowserMessageType,\r\n  message?: any\r\n}\r\n\r\nexport enum BrowserMessageType {\r\n  DEBUG = `${prefix}-debug`,\r\n  PING = `${prefix}-ping`,\r\n  PONG = `${prefix}-pong`,\r\n}","import { copyError } from '../utils/data-utils'\r\nimport { datadogLogs, LogsEvent } from '@datadog/browser-logs'\r\nimport { config } from '../config/config'\r\nimport { apiClient, DebugEntity } from '../api-client/api-client'\r\nimport { BrowserMessage, BrowserMessageType } from '../interfaces/message.interface'\r\n\r\ninterface LogEntry {\r\n  timestamp: string\r\n  type: 'log' | 'info' | 'warn' | 'error'\r\n  message: any[]\r\n}\r\n\r\nexport class BrowserLogger {\r\n  private static instance: BrowserLogger\r\n  private logs: LogEntry[] = []\r\n  private debugConfig: DebugEntity = { excludeErrorPattern: [], saveBundleErrorPattern: [] }\r\n  private initializationPromise: Promise<void>\r\n\r\n  private constructor() {\r\n    this.logs = []\r\n    this.initDd = this.initDd.bind(this)\r\n    this.error = this.error.bind(this)\r\n  }\r\n\r\n  private initDd() {\r\n    datadogLogs.init({\r\n      clientToken: 'pub1b40d87cd5789b981aad8bd37e4e01a4',\r\n      site: 'us3.datadoghq.com',\r\n      forwardErrorsToLogs: false,\r\n      sessionSampleRate: 100,\r\n      version: config.version,\r\n      service: 'canvas-quiz-loader',\r\n      env: config.env,\r\n      beforeSend: (log: LogsEvent): boolean => {\r\n        for (const pattern of this.debugConfig.excludeErrorPattern) {\r\n          if (log.message.includes(pattern)) return false\r\n        }\r\n        return true\r\n      },\r\n    })\r\n  }\r\n\r\n  public whenInitialized(): Promise<void> {\r\n    return this.initializationPromise\r\n  }\r\n\r\n  private getQuizEnv(): Promise<any> {\r\n    let resolver: (env: any) => void\r\n    let rejector: () => void\r\n    const timer = setTimeout(() => rejector, 2000)\r\n\r\n    const script = document.createElement('script')\r\n    script.src = browser.runtime.getURL('quiz-loader/injectable/get-env.js')\r\n    document.documentElement.appendChild(script)\r\n    script.remove()\r\n\r\n    window.addEventListener('quizEnv', (e: CustomEvent) => {\r\n      resolver(e.detail)\r\n      clearTimeout(timer)\r\n    })\r\n\r\n    return new Promise((resolve, reject) => {\r\n      resolver = resolve\r\n      rejector = reject\r\n    })\r\n  }\r\n\r\n  public static getInstance(): BrowserLogger {\r\n    if (!BrowserLogger.instance) {\r\n      const instance = new BrowserLogger()\r\n      BrowserLogger.instance = instance\r\n      let initResolver: () => void\r\n      this.instance.initializationPromise = new Promise((resolve) => (initResolver = resolve))\r\n      apiClient\r\n        .getDebugConfig()\r\n        .then((config) => (instance.debugConfig = config))\r\n        .catch(instance.error)\r\n        .finally(() => {\r\n          instance.initDd()\r\n          initResolver()\r\n        })\r\n    }\r\n    return BrowserLogger.instance\r\n  }\r\n\r\n  public async getLogBungle(): Promise<string> {\r\n    const logs: string[] = []\r\n\r\n    logs.push('--------------- HTML SECTION START ---------------\\n')\r\n    logs.push(document.documentElement.outerHTML)\r\n    logs.push('\\n--------------- HTML SECTION END ---------------\\n\\n')\r\n\r\n    logs.push('--------------- CANVAS ENV SECTION START ---------------\\n')\r\n    logs.push(JSON.stringify(await this.getQuizEnv(), null, 2))\r\n    logs.push('\\n--------------- CANVAS ENV SECTION END ---------------\\n\\n')\r\n\r\n    logs.push('--------------- LOGS SECTION START ---------------\\n')\r\n    logs.push(JSON.stringify(this.getLogs(), null, 2))\r\n    logs.push('\\n--------------- LOGS SECTION END ---------------\\n\\n')\r\n\r\n    return logs.join('')\r\n  }\r\n\r\n  private registerErrorListeners(): void {\r\n    window.addEventListener('error', (event: ErrorEvent): void => {\r\n      const { message, filename: source, lineno, colno, error } = event\r\n      this.error('Unhandled Error:', { message, source, lineno, colno, error })\r\n    })\r\n\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      const reason = event.reason\r\n      this.error('Unhandled Promise Rejection:', reason)\r\n    })\r\n  }\r\n\r\n  public startLogCapture(): void {\r\n    this.registerErrorListeners()\r\n\r\n    browser.runtime.onMessage.addListener(async (message: BrowserMessage, sender, sendResponse) => {\r\n      switch (message.type) {\r\n        case BrowserMessageType.DEBUG: {\r\n          return await this.getLogBungle()\r\n        }\r\n        case BrowserMessageType.PING: {\r\n          return BrowserMessageType.PONG\r\n        }\r\n        default:\r\n          return Promise.reject(new Error('Invalid type'))\r\n      }\r\n    })\r\n  }\r\n\r\n  public log(...args: any[]): void {\r\n    this._storeLog('log', ...args)\r\n    console.log(...args)\r\n  }\r\n\r\n  public info(...args: any[]): void {\r\n    this._storeLog('info', ...args)\r\n    console.info(...args)\r\n  }\r\n\r\n  public warn(...args: any[]): void {\r\n    this._storeLog('warn', ...args)\r\n    console.warn(...args)\r\n  }\r\n\r\n  public error(...args: any[]): void {\r\n    const firstError = args.find((e) => e instanceof Error)\r\n    this._storeLog('error', ...args.map(copyError))\r\n    const message = args.join(' ')\r\n    const saveBundle = this.debugConfig.saveBundleErrorPattern.findIndex((pattern) => message.includes(pattern)) !== -1\r\n    if (saveBundle) {\r\n      let bundleId: string\r\n      apiClient\r\n        .postDebugBundle(this.getLogBungle())\r\n        .then((id) => (bundleId = id))\r\n        .catch((e: Error) => {\r\n          console.error(e)\r\n          this._storeLog('error', copyError(e))\r\n          datadogLogs.logger.error(e.message, null, e)\r\n        })\r\n        .finally(() => datadogLogs.logger.error(`${message} bundleId: ${bundleId}`, null, firstError))\r\n    } else {\r\n      datadogLogs.logger.error(message, null, firstError)\r\n    }\r\n    console.error(...args)\r\n  }\r\n\r\n  private _storeLog(type: 'log' | 'info' | 'warn' | 'error', ...args: any[]): void {\r\n    const timestamp = new Date().toISOString()\r\n    this.logs.push({ timestamp, type, message: args })\r\n  }\r\n\r\n  public clearLogs(): void {\r\n    this.logs = []\r\n  }\r\n\r\n  public getLogs(): LogEntry[] {\r\n    return this.logs\r\n  }\r\n}\r\n","import { BrowserLogger } from '../logger/logger'\r\n\r\nconst logger = BrowserLogger.getInstance()\r\n\r\nexport async function getQuizSubmissions(courseId: number, quizId: number, baseUrl: string): Promise<any[]> {\r\n  const quizUrl = `${baseUrl}api/v1/courses/${courseId}/quizzes/${quizId}/`\r\n  const submissionsURL = quizUrl + 'submissions'\r\n\r\n  const [resQuiz, resSubmissions] = await Promise.all([fetch(quizUrl), fetch(submissionsURL)])\r\n  const [rawQuiz, rawSubmissions] = await Promise.all([resQuiz.text(), resSubmissions.text()])\r\n  const [quiz, submissions] = [JSON.parse(rawQuiz), JSON.parse(rawSubmissions).quiz_submissions]\r\n\r\n  /*\r\n    This case handles a quiz with a passcode\r\n    When a quiz with a passcode is loaded without any prior submissions and the passcode screen is presented to the user, we don't need to run the rest of the code\r\n   */\r\n  if (!submissions?.length) return []\r\n\r\n  const assignmentId = quiz.assignment_id\r\n  const userId = submissions.at(-1).user_id\r\n\r\n  if (!assignmentId) {\r\n    // if the quiz is a practice quiz, there will be no assignment id. Currently, this type of quiz is not supported\r\n    // TODO: add server side support for practice quizzes\r\n    logger.info('No assignment id found. This is a practice quiz')\r\n    return []\r\n  } else if (!userId) {\r\n    throw new Error('Unable to retrieve userId')\r\n  }\r\n\r\n  const submissionsHistoryUrl = `${baseUrl}api/v1/courses/${courseId}/assignments/${assignmentId}/submissions/${userId}?include[]=submission_history`\r\n  return fetch(submissionsHistoryUrl)\r\n    .then((res) => res.text())\r\n    .then((res) => JSON.parse(res).submission_history)\r\n}\r\n","export interface Question {\r\n  bestAnswer: Submission\r\n  latestAnswer: Submission\r\n  attempts: Submission[],\r\n}\r\n\r\nexport interface Questions {\r\n  [questionId: string]: Question\r\n}\r\n\r\nexport interface Submission {\r\n  correct: Correct\r\n  points: number\r\n  text: string\r\n  dynamicFields?: {\r\n    [dynamic: string]: any\r\n  }\r\n}\r\n\r\nexport enum Correct {\r\n  TRUE = 'true',\r\n  FALSE = 'false',\r\n  PARTIAL = 'partial',\r\n}\r\n\r\nexport enum QuestionType {\r\n  MULTIPLE_CHOICE,\r\n  TRUE_FALSE,\r\n  FILL_IN_BLANK,\r\n  FILL_IN_MULRIPLE_BLANKS,\r\n  MULTIPLE_ANSWER,\r\n  MULTIPLE_DROPDOWN,\r\n  MATCHING,\r\n  NUMERICAL_ANSWER,\r\n  FORMULA_QUESTION,\r\n  ESSAY_QUESTION\r\n}","const QuestionTypes = {\r\n    MULTIPLE_CHOICE: 'multiple_choice_question',\r\n    TRUE_FALSE: 'true_false_question',\r\n    FILL_IN_BLANK: 'short_answer_question',\r\n    FILL_IN_MULTIPLE_BLANKS: 'fill_in_multiple_blanks_question',\r\n    MULTIPLE_ANSWER: 'multiple_answers_question',\r\n    MULTIPLE_DROPDOWN: 'multiple_dropdowns_question',\r\n    MATCHING: 'matching_question',\r\n    NUMERICAL_ANSWER: 'numerical_question',\r\n    FORMULA_QUESTION: 'calculated_question',\r\n    ESSAY_QUESTION: 'essay_question'\r\n}\r\n\r\nexport default QuestionTypes;","import qt from './question-types'\r\nimport { getPointElements, isIncorrectChoice, getQuestionIds, wait } from './helpers'\r\nimport { Correct, Question, Questions } from './types/question'\r\nimport { BrowserLogger } from '../logger/logger'\r\n\r\nconst logger = BrowserLogger.getInstance()\r\n\r\nasync function waitForElementToBePresent(query: string, retry: number = 10): Promise<boolean> {\r\n  return new Promise(async (resolve) => {\r\n    const element = document.querySelector(query)\r\n    if (element) {\r\n      resolve(true)\r\n    } else {\r\n      if (retry <= 0) {\r\n        resolve(false)\r\n      } else {\r\n        await wait(0.2)\r\n        resolve(await waitForElementToBePresent(query, retry - 1))\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nasync function waitUntilPageLoaded(): Promise<void> {\r\n  const allQuestions = Array.from(document.querySelectorAll('.list_question'))\r\n  if (!allQuestions.length) return\r\n  const questionIds = allQuestions.map((question) => parseInt(question.id.split('_')[2]))\r\n  const current = document.querySelector('.list_question.current_question')\r\n  const targetQuestionId = current ? parseInt(current.id.split('_')[2]) : questionIds.at(-1)\r\n  const isLoaded = await waitForElementToBePresent(`#question_${targetQuestionId} .original_question_text`)\r\n  if (!isLoaded) {\r\n    const questions = document.getElementsByClassName('question_type')\r\n    if (questions.length) {\r\n      logger.error('This should not be happening. Not all questions loaded but there are questions on the page')\r\n    }\r\n  }\r\n}\r\n\r\nexport default async function display(questions: Questions) {\r\n  // await waitUntilPageLoaded()\r\n  const questionTypes = document.getElementsByClassName('question_type') as HTMLCollectionOf<HTMLElement>\r\n  const displayer = new Displayer()\r\n  const pointHolders = getPointElements()\r\n  const questionIds = getQuestionIds()\r\n\r\n  for (let i = 0; i < questionIds.length; i++) {\r\n    const questionType = questionTypes[i].innerText\r\n    const questionId = questionIds[i]\r\n\r\n    if (questions[questionId]) {\r\n      const question = questions[questionId]\r\n\r\n      try {\r\n        switch (questionType) {\r\n          case qt.ESSAY_QUESTION:\r\n            displayer.displayEssay(question, questionId)\r\n            break\r\n          case qt.MATCHING:\r\n            displayer.displayMatching(question, questionId)\r\n            break\r\n          case qt.MULTIPLE_DROPDOWN:\r\n            displayer.displayMultipleDropdowns(question, questionId)\r\n            break\r\n          case qt.MULTIPLE_ANSWER:\r\n            displayer.displayMultipleAnswer(question, questionId)\r\n            break\r\n          case qt.MULTIPLE_CHOICE:\r\n          case qt.TRUE_FALSE:\r\n            displayer.displayMultipleChoise(question, questionId)\r\n            break\r\n          case qt.FILL_IN_BLANK:\r\n          case qt.FORMULA_QUESTION:\r\n          case qt.NUMERICAL_ANSWER:\r\n            displayer.displayFillInBlank(question, questionId)\r\n            break\r\n          case qt.FILL_IN_MULTIPLE_BLANKS:\r\n            displayer.displayFillInMultipleBlank(question, questionId)\r\n            break\r\n        }\r\n      } catch (e) {\r\n        logger.error(`Failed to display question ${questionId} of type ${questionType} because of the error`, e)\r\n      }\r\n\r\n      const earnedPoints = Math.round(question.bestAnswer.points * 100) / 100\r\n      if (earnedPoints == parseFloat(pointHolders[i].innerText)) {\r\n        pointHolders[i].classList.add('correct-answer')\r\n      } else {\r\n        pointHolders[i].classList.add('incorrect-answer')\r\n      }\r\n      pointHolders[i].innerText = `${earnedPoints} out of ${pointHolders[i].innerText}`\r\n    } else {\r\n      pointHolders[i].innerText = `(New Question) ${pointHolders[i].innerText}`\r\n    }\r\n  }\r\n}\r\n\r\nexport class Displayer {\r\n  displayMatching(question: Question, questionId: number) {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const selectElements = document.querySelectorAll<HTMLSelectElement>(`#question_${questionId} select`)\r\n    for (const el of selectElements) {\r\n      if (el.value) return\r\n    }\r\n\r\n    const bestAnswer = question.bestAnswer\r\n\r\n    for (let answerProperty in bestAnswer.dynamicFields) {\r\n      if (answerProperty.includes('answer_')) {\r\n        const answerId = `question_${questionId}_${answerProperty}`\r\n        const input = document.getElementById(answerId) as HTMLInputElement\r\n        input.value = bestAnswer.dynamicFields[answerProperty]\r\n        input.dispatchEvent(new Event('change', { bubbles: true }))\r\n      }\r\n    }\r\n  }\r\n\r\n  displayMultipleDropdowns(question: Question, questionId: number): void {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const questionEl = document.getElementById(`question_${questionId}`)\r\n    const selectElements = document.querySelectorAll<HTMLSelectElement>(`#question_${questionId} select`)\r\n    for (const el of selectElements) {\r\n      if (el.value) return\r\n    }\r\n\r\n    const bestAnswer = question.bestAnswer\r\n    for (let answerProperty in bestAnswer.dynamicFields) {\r\n      if (answerProperty.includes('answer_id_for')) {\r\n        const answerId = bestAnswer.dynamicFields[answerProperty]\r\n        if (!answerId) continue\r\n        const selectEl: HTMLSelectElement = questionEl.querySelector(`option[value='${answerId}']`).parentElement as HTMLSelectElement\r\n        selectEl.value = answerId\r\n        selectEl.dispatchEvent(new Event('change', { bubbles: true }))\r\n      }\r\n    }\r\n  }\r\n\r\n  displayMultipleAnswer(question: Question, questionId: number) {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const checkboxElements = document.querySelectorAll<HTMLInputElement>(`#question_${questionId} input[type=\"checkbox\"]`)\r\n    for (const el of checkboxElements) {\r\n      if (el.checked) return\r\n    }\r\n\r\n    const bestAnswer = question.bestAnswer\r\n\r\n    for (let answerProperty in bestAnswer.dynamicFields) {\r\n      if (answerProperty.includes('answer_')) {\r\n        const answerId = `question_${questionId}_${answerProperty}`\r\n        const input = document.getElementById(answerId) as HTMLInputElement\r\n        input.checked = parseInt(bestAnswer.dynamicFields[answerProperty]) === 1\r\n        input.dispatchEvent(new Event('change', { bubbles: true }))\r\n      }\r\n    }\r\n  }\r\n\r\n  displayMultipleChoise(question: Question, questionId: number) {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const incorrectAnswers = new Set<number>()\r\n    for (const attempt of question.attempts) {\r\n      const answerId = parseInt(attempt.text)\r\n      if (attempt.correct !== Correct.TRUE && !isNaN(answerId)) incorrectAnswers.add(answerId)\r\n    }\r\n\r\n    for (let answerId of incorrectAnswers) {\r\n      const answerIDStr = `question_${questionId}_answer_${answerId}`\r\n      const el = document.getElementById(answerIDStr)\r\n      if (el)\r\n        // it will not exist if the option was removed after the student has already taken the quiz\r\n        el.parentElement.nextElementSibling.classList.add('incorrect-answer')\r\n    }\r\n\r\n    // prevent overriding user answer\r\n    const options = document.querySelectorAll<HTMLInputElement>(`#question_${questionId} input`)\r\n    for (let option of options) {\r\n      if (option.checked) return\r\n    }\r\n\r\n    if (!('answer_id' in question.bestAnswer.dynamicFields)) {\r\n      return\r\n    }\r\n\r\n    const answerId = `question_${questionId}_answer_${question.bestAnswer.text}`\r\n    const el = document.getElementById(answerId) as HTMLInputElement\r\n\r\n    if (!el) {\r\n      return\r\n    }\r\n\r\n    if (!isIncorrectChoice(el)) {\r\n      el.checked = true\r\n      el.dispatchEvent(new Event('change', { bubbles: true }))\r\n    }\r\n\r\n    // if only one left, select it\r\n    // if (!answer.correct === true) {\r\n    //    const possibleAnswers = el.parentElement.parentElement.parentElement.parentElement.children;\r\n    //    if (possibleAnswers.length - answer.attemptedAnswers.length === 1) {\r\n    //       for (let answerEl of possibleAnswers) {\r\n    //          const checkbox = answerEl.firstElementChild.firstElementChild.firstElementChild;\r\n    //          if (!isIncorrectChoice(checkbox)) {\r\n    //             checkbox.checked = true;\r\n    //          }\r\n    //       }\r\n    //    }\r\n    // }\r\n  }\r\n\r\n  displayFillInBlank(question: Question, questionId: number) {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const bestAnswer = question.bestAnswer\r\n\r\n    let element: HTMLInputElement = null\r\n    const elements = document.getElementsByName(`question_${questionId}`)\r\n    for (let el of elements) {\r\n      if (el.tagName === 'INPUT') {\r\n        element = el as HTMLInputElement\r\n        break\r\n      }\r\n    }\r\n\r\n    if (!element.value) {\r\n      element.value = bestAnswer.text\r\n      element.dispatchEvent(new Event('change', { bubbles: true }))\r\n    }\r\n  }\r\n\r\n  displayEssay(question: Question, questionId: number, retry = 15, interval = 500) {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const latestAnswer = question.latestAnswer\r\n\r\n    let topParent: HTMLElement\r\n    setTimeout(() => {\r\n      try {\r\n        topParent = document.getElementById(`question_${questionId}_question_text`)\r\n        const parent = topParent.nextElementSibling.querySelector<HTMLObjectElement>('#question_input_0_ifr')\r\n        const iframe = parent.contentDocument ? parent.contentDocument : parent.contentWindow.document\r\n        setTimeout(() => {\r\n          const input = iframe.getElementById('tinymce')\r\n          if (input.innerHTML == '<p><br data-mce-bogus=\"1\"></p>') {\r\n            input.innerHTML = latestAnswer.text\r\n            input.dispatchEvent(new Event('input', { bubbles: true }))\r\n          }\r\n        }, 0)\r\n      } catch (e) {\r\n        if (retry > 0) {\r\n          this.displayEssay(question, questionId, retry - 1)\r\n        } else {\r\n          topParent.innerHTML += `<b><div>Previous answer</div></b><p>${latestAnswer.text}</p>`\r\n        }\r\n      }\r\n    }, interval)\r\n  }\r\n\r\n  displayFillInMultipleBlank(question: Question, questionId: number) {\r\n    if (!question) {\r\n      return\r\n    }\r\n\r\n    const bestAnswer: { [dynamic: string]: any } = structuredClone(question.bestAnswer.dynamicFields)\r\n    for (const attempt of question.attempts) {\r\n      for (const field in attempt.dynamicFields) {\r\n        if (field.startsWith('answer_id_for_') && attempt.dynamicFields[field] != null) {\r\n          const valueKey = `answer_for${field.replace('answer_id_for', '')}`\r\n          bestAnswer[field] = attempt.dynamicFields[field]\r\n          bestAnswer[valueKey] = attempt.dynamicFields[valueKey]\r\n        }\r\n      }\r\n    }\r\n\r\n    const topParent = document.getElementById(`question_${questionId}_question_text`).parentElement\r\n    const bestAnswers = Object.keys(bestAnswer)\r\n      .filter((key) => key.includes('answer_for'))\r\n      .map((key) => {\r\n        const idKey = `answer_id_for${key.replace('answer_for', '')}`\r\n        const className = bestAnswer[idKey] != null ? 'checkmark' : 'cross'\r\n        return `<li class=\"${className}\">${key.replace(/_/g, ' ')}: ${bestAnswer[key]}</li>`\r\n      })\r\n\r\n    const latestAnswers = Object.keys(question.latestAnswer.dynamicFields)\r\n      .filter((key) => key.includes('answer_for'))\r\n      .map((key) => {\r\n        const idKey = `answer_id_for${key.replace('answer_for', '')}`\r\n        const className = question.latestAnswer.dynamicFields[idKey] != null ? 'checkmark' : 'cross'\r\n        return `<li class=\"${className}\">${key.replace(/_/g, ' ')}: ${question.latestAnswer.dynamicFields[key]}</li>`\r\n      })\r\n\r\n    const additionalHtml = `\r\n      <div class=\"fill-in-multiple-blank-extra-info\">\r\n        <div class=\"answers-panel\" >\r\n          <div class=\"best-answer\">\r\n            <h4>Best Answer</h4>\r\n            <ul class=\"answer-list\">\r\n              ${bestAnswers.join('')}\r\n            </ul>\r\n          </div>\r\n          <br>\r\n          <div class=\"latest-answer\">\r\n            <h4>Latest Answer</h4>\r\n            <ul class=\"answer-list\">\r\n              ${latestAnswers.join('')}\r\n            </ul>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    `\r\n\r\n    const parsedHtml = new DOMParser().parseFromString(additionalHtml, 'text/html')\r\n    topParent.prepend(parsedHtml.body.firstElementChild)\r\n  }\r\n}\r\n","export function getPointElements(): HTMLElement[] {\r\n    const pointHolders = document.getElementsByClassName('question_points_holder') as HTMLCollectionOf<HTMLElement>;\r\n    let cleanPointHolders = [];\r\n\r\n    // clean points\r\n    for (let pointHolder of pointHolders) {\r\n        const classList = pointHolder.parentElement.classList;\r\n        for (let i = 0; i < classList.length; i++) {\r\n            if (classList[i] == 'header') {\r\n                cleanPointHolders.push(pointHolder);\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    return cleanPointHolders;\r\n}\r\n\r\nexport function isIncorrectChoice(el: HTMLElement) {\r\n    return el.parentElement.nextElementSibling.className.includes('incorrect-answer');\r\n}\r\n\r\nexport function getQuestionIds() {\r\n    const questionIds: number[] = []\r\n    const questionTextEls = document.getElementsByClassName('original_question_text');\r\n    for (let el of questionTextEls) {\r\n        questionIds.push(parseInt(el.nextElementSibling.id.split('_')[1]));\r\n    }\r\n    return questionIds;\r\n}\r\n\r\nexport function wait(seconds: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, seconds * 1000))\r\n}","import { getQuizSubmissions } from './submissions'\r\nimport { getCorrectAnswers } from './answers'\r\nimport display from './display'\r\nimport { BrowserLogger } from '../logger/logger'\r\nimport { wait } from './helpers'\r\n\r\nconst logger = BrowserLogger.getInstance()\r\n\r\nexport async function main(): Promise<void> {\r\n  if (isByui()) await wait(2)\r\n  const currentURL = window.location.href\r\n  const courseId = parseInt(currentURL.split('courses/')[1].split('/')[0])\r\n  const quizId = parseInt(currentURL.split('quizzes/')[1].split('/')[0])\r\n  const urlTokens = currentURL.split('/')\r\n  const baseUrl = `${urlTokens[0]}//${urlTokens[2]}/`\r\n\r\n  if (!courseId) {\r\n    logger.error('Unable to retrieve course id')\r\n  } else if (!quizId) {\r\n    logger.error('Unable to retrieve quiz id')\r\n  }\r\n\r\n  const submissions = await getQuizSubmissions(courseId, quizId, baseUrl)\r\n  if (!submissions.length) return\r\n\r\n  const correctAnswers = getCorrectAnswers(submissions)\r\n  logger.info('correctAnswers:', correctAnswers)\r\n  logger.info('submissions:', submissions)\r\n\r\n  if (!correctAnswers) {\r\n    return null\r\n  }\r\n\r\n  await display(correctAnswers)\r\n}\r\n\r\nfunction isByui(): boolean {\r\n  return window.location.href.toLocaleLowerCase().includes('://byui.')\r\n  // maybe will need to include  || currentUrl.includes('byui.') || currentUrl.includes('byuh') in the future\r\n}\r\n\r\n/*\r\n    TODO\r\n    * Don't paste in inccorect answers (or have an option to view past answers)\r\n    * Don't overwrite what is already there\r\n    * Create seetings\r\n\r\n\r\n\r\n    Settings:\r\n    * Autoselect last available option in multiple choice and true/false questions\r\n    * Enable disable the app\r\n    * Multiple choice and True/False helper\r\n    *   disable incorrect answer\r\n    *   color code incorrect answer\r\n    * If correct answer is not found:\r\n    *   apply answer from latest attempt\r\n    *   apply best answer\r\n*/\r\n","import { main } from './quiz-loader'\r\nimport { BrowserLogger } from '../logger/logger'\r\n\r\nconst logger = BrowserLogger.getInstance()\r\nlogger.startLogCapture()\r\nlogger.whenInitialized().then(main)\r\n","import { Correct, Questions, Submission } from \"./types/question\";\r\nimport { pickBy } from '../utils/data-utils'\r\n\r\nexport function getCorrectAnswers(submissions: any): Questions {\r\n   if (!submissions[0].submission_data) {\r\n      return null;\r\n   }\r\n\r\n   const questions: Questions = {}\r\n   for (let i = 0; i < submissions.length; i++) {\r\n      const submission = submissions[i]\r\n      for (let questionSubmissionRaw of submission.submission_data) {\r\n         const questionId = questionSubmissionRaw.question_id\r\n         let correct: Correct\r\n\r\n         if (questionSubmissionRaw.correct == true)\r\n            correct = Correct.TRUE\r\n         else if (questionSubmissionRaw.correct == false)\r\n            correct = Correct.FALSE\r\n         else if (questionSubmissionRaw.correct == 'partial')\r\n            correct = Correct.PARTIAL\r\n\r\n\r\n         const questionSubmission: Submission = {\r\n            correct: correct,\r\n            text: questionSubmissionRaw.text,\r\n            points: questionSubmissionRaw.points,\r\n            dynamicFields: pickBy(questionSubmissionRaw, (value: any, key: any) => key.startsWith('answer'))\r\n         }\r\n         if (!(questionId in questions)) {\r\n            questions[questionId] = {\r\n               attempts: [],\r\n               bestAnswer: questionSubmission,\r\n               latestAnswer: questionSubmission\r\n            };\r\n         }\r\n\r\n         const question = questions[questionId]\r\n         question.attempts.push(questionSubmission);\r\n\r\n         if (questionSubmissionRaw.correct == true || question.bestAnswer.points < questionSubmissionRaw.points) {\r\n            question.bestAnswer = questionSubmission\r\n         };\r\n      }\r\n   }\r\n\r\n   return questions\r\n}\r\n\r\n\r\n"],"names":["pickBy","obj","predicate","Object","fromEntries","entries","filter","key","value","copyError","error","Error","clone","getOwnPropertyNames","forEach","ConsoleApiName","log","debug","info","warn","globalConsole","console","originalConsoleMethods","keys","name","PREFIX","display","bind","DOCS_ORIGIN","DOCS_TROUBLESHOOTING","MORE_DETAILS","catchUserErrors","fn","errorMsg","args","err","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitor","callMonitored","this","arguments","context","apply","e","displayIfDebugEnabled","monitorError","getGlobalObject","globalThis","defineProperty","prototype","get","configurable","globalObject","_dd_temp_","self","window","HAS_MULTI_BYTES_CHARACTERS","computeBytesCount","candidate","test","undefined","TextEncoder","encode","length","Blob","size","getZoneJsOriginalValue","target","browserWindow","original","Zone","__symbol__","callback","delay","timeoutId","throttle","wait","options","needLeadingExecution","leading","needTrailingExecution","trailing","pendingExecutionWithParameters","pendingTimeoutId","inWaitPeriod","throttled","parameters","cancel","jsonStringify","replacer","space","JSON","stringify","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","Array","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","_a","object","objectToJson","toJSON","objectHasValue","some","isEmptyObject","createCustomerDataTracker","checkCustomerDataLimit","bytesCountCache","computeBytesCountThrottled","cancelComputeBytesCount","resetBytesCount","updateCustomerData","resetCustomerData","getBytesCount","stop","getType","isArray","mergeInto","destination","source","circularReferenceChecker","WeakSet","set","hasAlreadyBeenSeen","has","add","array","indexOf","push","createCircularReferenceChecker","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","i","hasOwnProperty","call","deepClone","combine","sources","sanitize","maxCharacterCount","containerQueue","visitedObjectsWithPath","WeakMap","sanitizedData","sanitizeProcessor","serializedSanitizedData","accumulatedCharacterCount","containerToProcess","shift","separatorLength","targetData","path","warnOverCharacterLimit","parentPath","queue","sourceToSanitize","tryToApplyToJSON","toString","description","sanitizedSource","sanitizeObjects","sourceAsObject","currentPath","Event","type","event","isTrusted","currentTarget","match","changeType","Observable","constructor","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","other","notify","data","observer","mergeObservables","observables","globalObservable","subscriptions","map","observable","subscription","createContextManager","customerDataTracker","changeObservable","contextManager","getContext","setContext","newContext","clearContext","setContextProperty","property","removeContextProperty","TrackingConsent","GRANTED","NOT_GRANTED","addEventListener","configuration","eventTarget","eventName","listener","addEventListeners","eventNames","once","capture","passive","listenerWithMonitor","__ddIsTrusted","allowUntrustedEvents","listenerTarget","EventTarget","remove","storageListeners","storeContextManager","productKey","customerDataType","storageKey","buildStorageKey","getFromStorage","rawContext","localStorage","getItem","parse","setItem","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","startsWith","slice","split","line","stackFrame","parts","CHROME_LINE_RE","exec","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","url","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","ERROR_TYPES_RE","createHandlingStack","formattedStack","stackTrace","toStackTraceString","result","formatErrorMessage","frame","NO_ERROR_STACK_PRESENT_MESSAGE","computeRawError","originalError","handlingStack","startClocks","nonErrorPrefix","handling","isErrorInstance","isError","computeMessage","hasUsableStack","causes","flattenErrorCauses","fingerprint","tryToGetFingerprint","dd_fingerprint","parentSource","currentError","cause","ExperimentalFeature","enabledExperimentalFeatures","Set","INTAKE_SITE_US1","INTAKE_URL_PARAMETERS","ONE_SECOND","ONE_MINUTE","dateNow","timeStampNow","relativeNow","performance","now","clocksNow","relative","timeStamp","navigationStart","getNavigationStart","timing","sendToExtension","payload","__ddBrowserSdkExtensionCallback","performDraw","threshold","Math","random","getConnectivity","navigator","status","onLine","interfaces","connection","effective_type","effectiveType","removeItem","item","index","splice","buffer","drain","arg","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","preStartTelemetryBuffer","onRawTelemetryEventCollected","addTelemetryDebug","addTelemetryError","formatError","kind","scrubCustomerFrames","allowedFrameUrl","sanitizeUser","newUser","user","displayAlreadyInitializedError","sdkName","initConfiguration","silentMultipleInit","ErrorSource","isAuthorized","handlerType","logger","loggerHandler","getHandler","sanitizedHandlerType","STATUS_PRIORITIES","getLevel","includes","StatusType","ok","notice","critical","alert","emerg","createErrorFieldFromRawError","rawError","includeMessage","HandlerType","STATUSES","Logger","handleLogStrategy","level","loggerContext","logImplementation","messageContext","sanitizedMessageContext","setHandler","handler","setLevel","createLoggerMethod","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getCapabilities","getPrivacyLevel","getAllowedWebViewHosts","send","eventType","viewId","view","id","canUseEventBridge","currentHost","location","hostname","bridge","allowedHost","endsWith","instrumentMethod","targetPrototype","method","onPreCall","computeHandlingStack","stopped","instrumentation","from","postCallCallback","onPostCall","normalizeUrl","base","supportedURL","isURLSupported","originalURL","href","getSupportedUrl","doc","document","anchorElement","createElement","implementation","createHTMLDocument","baseElement","head","appendChild","body","buildUrl","decorators","desc","d","c","r","getOwnPropertyDescriptor","Reflect","decorate","__decorate","_","__","descriptor","originalMethod","URL","fetchObservable","initFetchObservable","fetch","input","init","methodFromParams","Request","toUpperCase","state","responsePromise","startContext","reportFetch","partialContext","assign","then","response","responseType","isAborted","_b","signal","aborted","DOMException","code","ABORT_ERR","afterSend","beforeSend","generateUUID","placeholder","parseInt","replace","COMMA_SEPARATED_KEY_VALUE","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","browserCache","initCookieParsed","getCurrentSiteCache","setCookie","expireDelay","date","setTime","expires","toUTCString","sameSite","crossSite","domain","secure","partitioned","cookie","getCookie","rawString","lastIndex","findCommaSeparatedValue","getInitCookie","Map","findCommaSeparatedValues","deleteCookie","SESSION_STORE_KEY","objectValues","values","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","SessionPersistence","SESSION_ENTRY_REGEXP","getExpiredSessionState","previousSessionState","expiredSessionState","isExpired","trackAnonymousUser","anonymousId","floor","pow","padStart","isSessionInNotStartedState","session","isSessionStarted","isSessionInExpiredState","sessionState","created","Number","expire","expandSessionState","toSessionString","toSessionState","sessionString","isValidSessionString","entry","matches","selectCookieStrategy","cookieOptions","useSecureSessionCookie","usePartitionedCrossSiteSessionCookie","trackSessionAcrossSubdomains","testCookieName","testCookieValue","domainLevels","candidateDomain","pop","getCurrentSite","buildCookieOptions","isCookieCorrectlySet","areCookiesAuthorized","retrieveSessionCookie","selectLocalStorageStrategy","testKey","retrievedId","persistInLocalStorage","retrieveSessionFromLocalStorage","bufferedOperations","ongoingOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","isLockEnabled","persistSession","expireSession","persistWithLock","lock","currentLock","retrieveStore","retrieveSession","next","currentStore","retryLater","processedSession","process","after","sessionStore","currentNumberOfRetries","nextOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","sessionPersistence","sessionStoreStrategyType","allowFallbackToLocalStorage","startSessionStore","computeSessionState","renewObservable","expireObservable","sessionStateUpdateObservable","cookieStore","userAgent","chrome","vendor","detectBrowser","expireSessionCookie","cookieStoreStrategy","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","initCookieStrategy","expireSessionFromLocalStorage","initLocalStorageStrategy","watchSessionTimeoutId","synchronizeSession","sessionCache","startSession","throttledExpandOrRenewSession","cancelExpandOrRenewSession","synchronizedSession","trackingType","isTracked","expandOrRenewSessionState","hasSessionInCache","renewSessionInCache","isSessionInCacheOutdated","previousState","newState","expandOrRenewSession","expandSession","getSession","restartSession","updateSessionState","partialSessionState","createEndpointBuilder","trackType","configurationTags","buildUrlWithParameters","proxy","normalizedProxyUrl","encodeURIComponent","host","site","internalAnalyticsSubdomain","usePciIntake","domainParts","extension","buildEndpointHost","createEndpointUrlWithParametersBuilder","build","api","clientToken","retry","encoding","tags","concat","count","lastFailureStatus","reverse","buildEndpointParameters","urlPrefix","buildTag","rawValue","valueSizeLimit","supportUnicodePropertyEscapes","hasForbiddenCharacters","computeTransportConfiguration","env","service","version","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isString","tag","tagName","isSampleRate","sampleRate","RawReportType","intervention","deprecation","cspViolation","buildRawReportError","partial","buildStack","sourceFile","lineNumber","columnNumber","validateAndBuildForwardOption","option","allowedValues","label","every","removeDuplicates","createPreStartStrategy","getCommonContext","trackingConsentState","doStartLogs","bufferApiCalls","cachedInitConfiguration","cachedConfiguration","trackingConsentStateSubscription","tryStartLogs","isGranted","startLogsResult","enableExperimentalFeatures","flag","overrideInitConfigurationForBridge","baseConfiguration","_c","_d","_e","_f","sessionSampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","telemetryUsageSampleRate","trackingConsent","storeContextsAcrossPages","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","validateAndBuildConfiguration","forwardConsoleLogs","forwardReports","forwardErrorsToLogs","requestErrorResponseLengthLimit","validateAndBuildLogsConfiguration","tryToInit","getInternalContext","handleLog","statusType","LOGS_STORAGE_KEY","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getSyntheticsTestId","_DATADOG_SYNTHETICS_PUBLIC_ID","getSyntheticsResultId","_DATADOG_SYNTHETICS_RESULT_ID","END_OF_TIMES","Infinity","SESSION_CONTEXT_TIMEOUT_DELAY","stopCallbacks","startSessionManager","sessionContextHistory","maxEntries","clearOldValuesInterval","oldTimeThreshold","endTime","clearOldValues","startTime","close","unshift","find","returnInactive","closeActive","latestEntry","findAll","duration","reset","createValueHistory","buildSessionContext","isReplayForced","forcedReplay","clocksOrigin","trackActivity","expandSessionWhenVisible","visibilityState","visibilityCheckInterval","trackVisibility","trackResume","findSession","computeTrackingType","logsSentBeforeRumInjectionTelemetryAdded","getRUMInternalContext","getInternalContextFromRumGlobal","DD_RUM_SYNTHETICS","testId","resultId","DD_RUM","rumGlobal","startLogsAssembly","sessionManager","lifeCycle","reportError","statusWithCustom","logRateLimiters","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","createEventRateLimiter","rawLogsEvent","savedCommonContext","domainContext","findTrackedSession","commonContext","anonymous_id","session_id","usr","origin","consoleObservablesByApi","LogStatusForApi","xhrObservable","xhrContexts","openXhr","xhr","abortXhr","isServerError","startNetworkErrorCollection","xhrSubscription","stopInstrumentingStart","XMLHttpRequest","stopInstrumentingSend","hasBeenReported","stopInstrumentingOnReadyStateChange","readyState","DONE","onEnd","unsubscribeLoadEndListener","completeContext","start","sendXhr","stopInstrumentingAbort","createXhrObservable","initXhrObservable","handleResponse","fetchSubscription","request","onResponseDataAvailable","responseData","format","http","status_code","param","isRejected","truncateResponseText","computeXhrResponseData","clonedResponse","tryToClone","TextDecoder","stream","bytesLimit","reader","getReader","chunks","readBytesCount","onDone","bytes","limitExceeded","catch","collectStreamBody","completeBuffer","Uint8Array","offset","chunk","readMore","read","done","readBytesFromStream","responseText","decode","truncateResponseStream","text","computeFetchResponseText","computeFetchErrorText","substring","trackRuntimeError","errorObservable","handleRuntimeError","stopInstrumentingOnError","messageObj","errorObj","tryToParseMessage","computeStackTraceFromOnErrorMessage","stopInstrumentingOnUnhandledRejection","reason","instrumentUnhandledRejection","LifeCycle","callbacks","eventCallbacks","loggerToConsoleApiName","createBatch","encoder","flushController","upsertBuffer","flushSubscription","flushObservable","upsertMessages","isPageExit","sendOnExit","isAsync","encoderResult","finishSync","outputBytesCount","formatPayloadFromEncoder","pendingMessages","pendingData","bytesCount","write","isEmpty","finish","flush","addOrUpdate","serializedMessage","estimatedMessageBytesCount","estimateEncodedBytesCount","hasMessageFor","removedMessage","messageBytesCount","notifyAfterRemoveMessage","notifyBeforeAddMessage","notifyAfterAddMessage","realMessageBytesCount","upsert","output","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","sendStrategy","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","first","dequeue","currentBackoffTime","min","shouldRetryRequest","ongoingRequestCount","isFull","queueFullReported","previousQueue","newPayloadQueue","createHttpRequest","endpointBuilder","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","isKeepAliveSupported","fetchUrl","keepalive","mode","sendXHR","fetchKeepAliveStrategy","sendBeacon","beaconUrl","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","open","setRequestHeader","createFlushController","messagesLimit","durationLimit","pageExitObservable","sessionExpireObservable","pageExitSubscription","sessionExpireSubscription","durationLimitTimeoutId","currentBytesCount","currentMessagesCount","flushReason","messagesCount","cancelDurationLimitTimeout","messageBytesCountDiff","startBatchWithReplica","primary","batchFactoryImp","primaryBatch","createBatchFromConfig","replicaBatch","endpoint","replicated","transformMessage","createIdentityEncoder","additionalEncodedBytesCount","rawBytesCount","startLogsTelemetry","telemetry","telemetryService","contextProvider","alreadySentEvents","telemetryEnabled","telemetryEnabledPerType","runtimeEnvInfo","is_local_file","protocol","is_worker","rawEvent","stringifiedEvent","_dd","format_version","runtime_env","connectivity","sdk_setup","experimental_features","toTelemetryEvent","setContextProvider","provider","enabled","startTelemetry","application","application_id","action","user_action","cleanupTasks","telemetrySubscription","telemetryBatch","isTelemetryReplicationAllowed","addTelemetryConfiguration","baseSerializedInitConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","telemetry_usage_sample_rate","use_before_send","use_partitioned_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","track_anonymous_user","session_persistence","allow_fallback_to_local_storage","store_contexts_across_pages","allow_untrusted_events","tracking_consent","forward_errors_to_logs","forward_console_logs","forward_reports","use_pci_intake","serializeLogsConfiguration","task","datadogLogs","customerDataTrackerManager","compressionStatus","customerDataTrackers","alreadyWarned","initialBytesCount","bytesCountLimit","tracker","displayCustomerDataLimitReachedWarning","createDetachedTracker","getOrCreateTracker","setCompressionStatus","newCompressionStatus","getCompressionStatus","clear","createCustomerDataTrackerManager","globalContextManager","userContextManager","currentConsent","update","createTrackingConsentState","referrer","buildCommonContext","strategy","startReportError","stopListeners","stopBeforeUnloadListener","createPageExitObservable","startLogsSessionManagerStub","rawTrackingType","rawSessionType","hasValidLoggerSession","startLogsSessionManager","stopLogsTelemetry","rawErrorObservable","stopRuntimeErrorTracking","startRuntimeErrorCollection","apis","originalConsoleApi","params","formatConsoleParameters","firstErrorParam","buildConsoleLog","createConsoleObservable","collectedData","startConsoleCollection","blockedURI","effectiveDirective","csp","disposition","originalPolicy","buildRawReportErrorFromCspViolation","createCspViolationReportObservable","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportErrorFromReport","types","buffered","observe","disconnect","createReportObservable","initReportObservable","startReportCollection","logsMessage","savedDate","displayInConsole","rawLogEventData","startLoggerCollection","serverLogsEvent","startLogsBridge","stopLogsBatch","batch","startLogsBatch","trackedSession","startLogsImpl","createPostStartStrategy","customLoggers","stub","publicApi","onReady","enumerable","makePublicApi","setTrackingConsent","usage","feature","getGlobalContext","setGlobalContext","setGlobalContextProperty","removeGlobalContextProperty","clearGlobalContext","createLogger","conf","getLogger","getInitConfiguration","setUser","isValid","checkUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","clearUser","makeLogsPublicApi","existingGlobalVariable","q","defineGlobal","apiClient","baseUrl","isHealthy","getDebugConfig","statusText","json","postDebugBundle","headers","isPromise","BrowserMessageType","BrowserLogger","logs","debugConfig","excludeErrorPattern","saveBundleErrorPattern","initDd","pattern","whenInitialized","initializationPromise","getQuizEnv","resolver","rejector","timer","setTimeout","script","src","browser","runtime","getURL","documentElement","detail","clearTimeout","Promise","resolve","reject","getInstance","instance","initResolver","config","finally","getLogBungle","outerHTML","getLogs","registerErrorListeners","filename","lineno","colno","startLogCapture","onMessage","addListener","sender","sendResponse","DEBUG","PING","PONG","_storeLog","firstError","findIndex","bundleId","timestamp","toISOString","clearLogs","Correct","QuestionType","questions","questionTypes","getElementsByClassName","displayer","Displayer","pointHolders","cleanPointHolders","pointHolder","classList","parentElement","getPointElements","questionIds","questionTextEls","el","nextElementSibling","getQuestionIds","questionType","innerText","questionId","question","displayEssay","displayMatching","displayMultipleDropdowns","displayMultipleAnswer","displayMultipleChoise","displayFillInBlank","displayFillInMultipleBlank","earnedPoints","round","bestAnswer","points","parseFloat","selectElements","querySelectorAll","answerProperty","dynamicFields","answerId","getElementById","dispatchEvent","bubbles","questionEl","selectEl","querySelector","checkboxElements","checked","incorrectAnswers","attempt","attempts","correct","TRUE","isNaN","answerIDStr","className","isIncorrectChoice","element","elements","getElementsByName","interval","latestAnswer","topParent","parent","iframe","contentDocument","contentWindow","innerHTML","structuredClone","field","valueKey","bestAnswers","idKey","latestAnswers","additionalHtml","parsedHtml","DOMParser","parseFromString","prepend","firstElementChild","toLocaleLowerCase","seconds","currentURL","courseId","quizId","urlTokens","submissions","quizUrl","submissionsURL","resQuiz","resSubmissions","all","rawQuiz","rawSubmissions","quiz","quiz_submissions","assignmentId","assignment_id","userId","at","user_id","res","submission_history","getQuizSubmissions","correctAnswers","submission_data","submission","questionSubmissionRaw","question_id","FALSE","PARTIAL","questionSubmission","getCorrectAnswers"],"sourceRoot":""}